<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MantraOS</title>
  
  <!-- Tailwind CDN used for hackathon simplicity; compile for production -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- PWA Manifest & Themeing -->
  <meta name="theme-color" content="#667eea">
  <link rel="manifest" href="manifest.json">
  <!-- Ensure icon-192.svg exists or use icon-192.png as fallback -->
  <link rel="apple-touch-icon" href="/icon-192.png">


  <script>
    // Custom Tailwind theme configuration
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            'sans': ['Poppins', 'sans-serif'],
            'serif': ['Playfair Display', 'serif'],
          },
          colors: {
            'deep-purple': '#667eea',
            'gold': '#f6d365',
            'teal': '#4facfe',
            'charcoal': '#333333',
          },
          animation: {
            'fade-in': 'fadeIn 0.5s ease-in-out',
            'slide-in-up': 'slideInUp 0.5s ease-in-out',
            'toast-in': 'toastIn 0.3s ease-out forwards',
            'toast-out': 'toastOut 0.3s ease-in forwards',
            'confetti-fall': 'confettiFall 3s ease-out forwards',
            'slideshow-progress': 'slideshowProgress linear forwards',
            'float': 'float 8s ease-in-out infinite',
            'gradient-shift': 'gradientShift 20s ease infinite',
            'pulse-ring': 'pulseRing 2s ease-out infinite',
            'spin': 'spin 1s linear infinite',
            'particle-effect': 'particleEffect 1s ease-out forwards',
          },
          keyframes: {
            fadeIn: {
              '0%': { opacity: '0' },
              '100%': { opacity: '1' },
            },
            slideInUp: {
              '0%': { transform: 'translateY(20px)', opacity: '0' },
              '100%': { transform: 'translateY(0)', opacity: '1' },
            },
            toastIn: {
                '0%': { transform: 'translateY(100%)', opacity: '0' },
                '100%': { transform: 'translateY(0)', opacity: '1' },
            },
            toastOut: {
                '0%': { transform: 'translateY(0)', opacity: '1' },
                '100%': { transform: 'translateY(100%)', opacity: '0' },
            },
            pulseRing: {
                '0%': { transform: 'scale(0.8)', opacity: '1' },
                '100%': { transform: 'scale(2.5)', opacity: '0' }
            },
            confettiFall: {
                '0%': { transform: 'translateY(-10vh) rotateZ(0deg)', opacity: 1 },
                '100%': { transform: 'translateY(110vh) rotateZ(360deg)', opacity: 0 },
            },
            slideshowProgress: {
                '0%': { width: '0%' },
                '100%': { width: '100%' },
            },
            float: {
              '0%, 100%': { transform: 'translateY(-5px)' },
              '50%': { transform: 'translateY(5px)' },
            },
            gradientShift: {
              '0%, 100%': { backgroundPosition: '0% 50%' },
              '50%': { backgroundPosition: '100% 50%' },
            },
            spin: {
              'from': { transform: 'rotate(0deg)' },
              'to': { transform: 'rotate(360deg)' },
            },
            particleEffect: {
                '0%': { transform: 'scale(0.5) translateY(0)', opacity: 0 },
                '20%': { opacity: 1 },
                '100%': { transform: 'scale(1.2) translateY(-80px)', opacity: 0 },
            },
          }
        }
      }
    }
  </script>
  
  <style>
    /* Basic styles for glassmorphism, theme transitions, and UI elements */
    :root {
      --font-family: 'Poppins', sans-serif;
    }
    html {
        font-family: var(--font-family);
    }
    body {
      transition: background 0.5s ease-in-out, color 0.5s ease-in-out;
    }
    .glass-card {
      background: rgba(255, 255, 255, 0.1);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .text-charcoal .glass-card {
        background: rgba(0, 0, 0, 0.05);
        border: 1px solid rgba(0, 0, 0, 0.1);
    }
    .dark .glass-card {
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .theme-gradient-1 { background-image: linear-gradient(to top right, #667eea, #764ba2); }
    .theme-gradient-2 { background-image: linear-gradient(to top right, #f6d365, #fda085); }
    .theme-gradient-3 { background-image: linear-gradient(to top right, #4facfe, #00f2fe); }
    .theme-gradient-4 { background-image: linear-gradient(to top right, #434343, #000000); }

    /* Confetti styles */
    .confetti-piece {
        position: absolute;
        width: 8px;
        height: 16px;
        top: -20px;
        will-change: transform, opacity;
    }
    
    /* Transition particle styles */
    .transition-particle {
        position: absolute;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        pointer-events: none;
        will-change: transform, opacity;
    }

    /* Accessibility: Reduce motion */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-delay: -1ms !important;
        animation-duration: 1ms !important;
        animation-iteration-count: 1 !important;
        background-attachment: initial !important;
        scroll-behavior: auto !important;
        transition-duration: 0s !important;
        transition-delay: 0s !important;
      }
      .animate-float {
        animation: none !important;
      }
    }
  </style>

</head>
<body class="antialiased">
  <div id="root"></div>
  <div id="toast-container" class="fixed bottom-24 left-1/2 -translate-x-1/2 z-[120] w-full max-w-sm px-4"></div>

  <script type="module">
    // --- ICONS (Lucide via esm.sh as self-contained functions) ---
    const createIcon = (iconName, svgContent) => (props = {}) => {
        const { size = 24, color = 'currentColor', className = '' } = props;
        const element = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        element.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        element.setAttribute('width', size);
        element.setAttribute('height', size);
        element.setAttribute('viewBox', '0 0 24 24');
        element.setAttribute('fill', 'none');
        element.setAttribute('stroke', color);
        element.setAttribute('stroke-width', '2');
        element.setAttribute('stroke-linecap', 'round');
        element.setAttribute('stroke-linejoin', 'round');
        if(className) element.setAttribute('class', className);
        element.innerHTML = svgContent;
        return element.outerHTML;
    };

    const ICONS = {
        Zap: createIcon('Zap', '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>'),
        Layers: createIcon('Layers', '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>'),
        Check: createIcon('Check', '<polyline points="20 6 9 17 4 12"></polyline>'),
        Edit: createIcon('Edit', '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>'),
        CheckCircle: createIcon('CheckCircle', '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>'),
        XCircle: createIcon('XCircle', '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>'),
        PlusCircle: createIcon('PlusCircle', '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>'),
        Home: createIcon('Home', '<path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>'),
        Library: createIcon('Library', '<path d="m16 6 4 14"></path><path d="M12 6v14"></path><path d="M8 8v12"></path><path d="M4 4v16"></path>'),
        BarChart2: createIcon('BarChart2', '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>'),
        Settings: createIcon('Settings', '<path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0 2l.15.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle>'),
        Plus: createIcon('Plus', '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>'),
        Trash2: createIcon('Trash2', '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>'),
        Award: createIcon('Award', '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>'),
        Bell: createIcon('Bell', '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>'),
        Smile: createIcon('Smile', '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>'),
        ArrowLeft: createIcon('ArrowLeft', '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>'),
        ArrowRight: createIcon('ArrowRight', '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>'),
        Search: createIcon('Search', '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>'),
        Download: createIcon('Download', '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>'),
        Upload: createIcon('Upload', '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/>'),
        Microphone: createIcon('Microphone', '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line>'),
        MicOff: createIcon('MicOff', '<line x1="16" x2="16" y1="13" y2="22"></line><line x1="8" x2="8" y1="13" y2="17"></line><path d="M12 1v8"></path><path d="M20 10v2a8 8 0 0 1-16 0v-2"></path><line x1="1" x2="23" y1="1" y2="23"></line>'),
        Play: createIcon('Play', '<polygon points="5 3 19 12 5 21 5 3"></polygon>'),
        Pause: createIcon('Pause', '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>'),
        StopCircle: createIcon('StopCircle', '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>'),
        Trophy: createIcon('Trophy', '<path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/>'),
        Music4: createIcon('Music4', '<path d="M9 18V5l12-2v13"/><path d="m9 9 12-2"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/>'),
        Timer: createIcon('Timer', '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>'),
        Vibrate: createIcon('Vibrate', '<path d="m2 8 2.18-1.37a2 2 0 0 1 2.64 0L10 8"/><path d="m14 8 2.18-1.37a2 2 0 0 1 2.64 0L22 8"/><path d="M7 13h10"/><path d="M9 17h6"/><path d="M2 12H0"/><path d="M24 12h-2"/><path d="m5 21 2-4"/><path d="m19 21-2-4"/><path d="M19 5l-2 4"/><path d="m5 5 2 4"/>'),
        RotateCcw: createIcon('RotateCcw', '<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/>'),
        RotateCw: createIcon('RotateCw', '<path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/>'),
        Sparkles: createIcon('Sparkles', '<path d="m12 3-1.9 5.8a2 2 0 0 1-1.3 1.3L3 12l5.8 1.9a2 2 0 0 1 1.3 1.3L12 21l1.9-5.8a2 2 0 0 1 1.3-1.3L21 12l-5.8-1.9a2 2 0 0 1-1.3-1.3Z"/>'),
        Languages: createIcon('Languages', '<path d="m5 8 6 6"/><path d="m4 14 6-6 2-3"/><path d="M2 5h12"/><path d="M7 2h1"/><path d="m22 22-5-10-5 10"/><path d="M14 18h6"/>'),
        Globe: createIcon('Globe', '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-2z"></path>'),
        Wand2: createIcon('Wand2', '<path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M11.8 17.8 13 19"/><path d="M19 11.8 17.8 13"/><path d="M13 11.8 11.8 13"/><path d="m21.1 12.3-1.1 1.1a4.9 4.9 0 0 1-7 7l-1.8-1.8a4.9 4.9 0 0 1 7-7l1.1-1.1Z"/><path d="M3 21a2.4 2.4 0 0 1 0-3.4l3.1-3.1"/>'),
        Cpu: createIcon('Cpu', '<rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M15 2v2"/><path d="M15 20v2"/><path d="M2 15h2"/><path d="M2 9h2"/><path d="M20 15h2"/><path d="M20 9h2"/><path d="M9 2v2"/><path d="M9 20v2"/>'),
    };

    // --- COLOR & THEME UTILS ---
    const getTextColorClasses = () => {
        const theme = state.settings.theme;
        const needsDarkText = theme === 'theme-gradient-2' || theme === 'theme-gradient-3';
        return {
            primary: needsDarkText ? 'text-charcoal' : 'text-white',
            secondary: needsDarkText ? 'text-charcoal/80' : 'text-white/80',
            tertiary: needsDarkText ? 'text-charcoal/60' : 'text-white/60',
            accent: needsDarkText ? 'text-deep-purple' : 'text-teal',
            placeholder: needsDarkText ? 'placeholder-charcoal/50' : 'placeholder-white/50',
            bgMuted: needsDarkText ? 'bg-black/10' : 'bg-white/10',
            bgMuted20: needsDarkText ? 'bg-black/20' : 'bg-white/20',
            bgHover: needsDarkText ? 'hover:bg-black/20' : 'hover:bg-white/20',
            bgHover30: needsDarkText ? 'hover:bg-black/30' : 'hover:bg-white/30',
            ring: needsDarkText ? 'focus:ring-charcoal' : 'focus:ring-white',
            border: needsDarkText ? 'border-black/20' : 'border-white/20',
            accentCheckbox: needsDarkText ? 'accent-deep-purple' : 'accent-teal',
            needsDarkText,
        };
    };

    // --- CHROME AI ---
    let aiTextSession = null;
    let aiTranslator = null;
    const isAnyAiFeatureEnabled = () => state.settings.aiFeatures.enabled && (state.aiStatus.supported || state.settings.demoMode.enabled);

    const checkAiStatus = async () => {
        console.log('[MantraOS AI Diagnostics] Starting AI feature check...');
        const status = {
            checked: true,
            supported: typeof window.ai !== 'undefined',
            text: false,
            translator: false,
            rewriter: false,
            proofreader: false,
            assistant: false
        };

        if (status.supported) {
            console.log('[MantraOS AI Diagnostics] window.ai object found.');
            try {
                await window.ai.createTextSession();
                status.text = true;
                console.log('[MantraOS AI Diagnostics] createTextSession: Available');
            } catch (e) { console.log('[MantraOS AI Diagnostics] createTextSession: Unavailable', e.message); }

            try {
                await window.ai.translator.create();
                status.translator = true;
                console.log('[MantraOS AI Diagnostics] translator.create: Available');
            } catch (e) { console.log('[MantraOS AI Diagnostics] translator.create: Unavailable', e.message); }

            try {
                await window.ai.rewriter.create();
                status.rewriter = true;
                console.log('[MantraOS AI Diagnostics] rewriter.create: Available');
            } catch (e) { console.log('[MantraOS AI Diagnostics] rewriter.create: Unavailable', e.message); }

            try {
                await window.ai.proofreader.create();
                status.proofreader = true;
                console.log('[MantraOS AI Diagnostics] proofreader.create: Available');
            } catch (e) { console.log('[MantraOS AI Diagnostics] proofreader.create: Unavailable', e.message); }

            try {
                if (window.ai.assistant && await window.ai.assistant.canPrompt({audio: true})) {
                    status.assistant = true;
                    console.log('[MantraOS AI Diagnostics] assistant.canPrompt({audio: true}): Available');
                } else {
                     console.log('[MantraOS AI Diagnostics] assistant.canPrompt({audio: true}): Unavailable');
                     renderToast('AI audio input unavailable.');
                }
            } catch (e) { console.log('[MantraOS AI Diagnostics] assistant.canPrompt: Unavailable', e.message); }
        } else {
            console.log('[MantraOS AI Diagnostics] window.ai object not found. AI features are unavailable.');
            renderToast('AI features unavailable. Using demo mode.');
        }
        state.aiStatus = status;
        console.log('[MantraOS AI Diagnostics] Check complete. Final status:', state.aiStatus);
    };

    // --- CONSTANTS ---
    const CATEGORIES = ['Money', 'Health', 'Relationships', 'Career', 'Confidence', 'AI Generated'];
    const PRIORITIES = { Low: 'bg-sky-500', Medium: 'bg-yellow-500', High: 'bg-rose-500' };
    const PRIORITY_LEVELS = ['Low', 'Medium', 'High'];
    const CURATED_MANTRAS = [
      { id: 'm1', text: { original: 'Money flows to me easily, frequently, and abundantly.', translated: null }, category: 'Money' }, { id: 'm2', text: { original: 'I am a magnet for financial prosperity and wealth.', translated: null }, category: 'Money' }, { id: 'm3', text: { original: 'Wealth constantly circulates in my life.', translated: null }, category: 'Money' }, { id: 'm4', text: { original: 'I am worthy of building and receiving massive wealth.', translated: null }, category: 'Money' }, { id: 'm5', text: { original: 'My income is constantly increasing.', translated: null }, category: 'Money' },
      { id: 'h1', text: { original: 'My body is a magnificent vessel of health and vitality.', translated: null }, category: 'Health' }, { id: 'h2', text: { original: 'I choose vibrant health and boundless energy.', translated: null }, category: 'Health' }, { id: 'h3', text: { original: 'My body heals itself quickly and easily.', translated: null }, category: 'Health' }, { id: 'h4', text: { original: 'I nourish my body with healthy food and positive thoughts.', translated: null }, category: 'Health' }, { id: 'h5', text: { original: 'Every cell in my body is alive with energy.', translated: null }, category: 'Health' },
      { id: 'r1', text: { original: 'I attract loving, supportive, and harmonious relationships.', translated: null }, category: 'Relationships' }, { id: 'r2', text: { original: 'I communicate with clarity, honesty, and compassion.', translated: null }, category: 'Relationships' }, { id: 'r3', text: { original: 'I give and receive love effortlessly and unconditionally.', translated: null }, category: 'Relationships' }, { id: 'r4', text: { original: 'I am surrounded by people who love and respect me.', translated: null }, category: 'Relationships' }, { id: 'r5', text: { original: 'My heart is open to meaningful connections.', translated: null }, category: 'Relationships' },
      { id: 'cr1', text: { original: 'Amazing career opportunities find their way to me.', translated: null }, category: 'Career' }, { id: 'cr2', text: { original: 'My work makes a positive impact and inspires others.', translated: null }, category: 'Career' }, { id: 'cr3', text: { original: 'I am valued and respected for my unique talents.', translated: null }, category: 'Career' }, { id: 'cr4', text: { original: 'I am confident in my abilities and excel in my profession.', translated: null }, category: 'Career' }, { id: 'cr5', text: { original: 'I am on the perfect path for my career success.', translated: null }, category: 'Career' },
      { id: 'c1', text: { original: 'I am enough, just as I am.', translated: null }, category: 'Confidence' }, { id: 'c2', text: { original: 'My voice is valuable and my opinion matters.', translated: null }, category: 'Confidence' }, { id: 'c3', text: { original: 'I embrace challenges as opportunities to grow stronger.', translated: null }, category: 'Confidence' }, { id: 'c4', text: { original: 'I am confident, capable, and in control of my life.', translated: null }, category: 'Confidence' }, { id: 'c5', text: { original: 'I release all self-doubt and welcome self-love.', translated: null }, category: 'Confidence' },
    ];
    const THEME_OPTIONS = [
        { id: 'theme-gradient-1', name: 'Cosmic Cobalt', gradient: 'linear-gradient(to top right, #667eea, #764ba2)' }, { id: 'theme-gradient-2', name: 'Sunset Flare', gradient: 'linear-gradient(to top right, #f6d365, #fda085)' }, { id: 'theme-gradient-3', name: 'Aqua Marine', gradient: 'linear-gradient(to top right, #4facfe, #00f2fe)' }, { id: 'theme-gradient-4', name: 'Midnight Onyx', gradient: 'linear-gradient(to top right, #434343, #000000)' },
    ];
    const FONT_OPTIONS = [ { id: 'font-sans', name: 'Poppins (Modern)'}, { id: 'font-serif', name: 'Playfair (Elegant)'},];
    const SUPPORTED_LANGUAGES = { 'en': 'English', 'es': 'Español', 'fr': 'Français', 'de': 'Deutsch', 'ja': '日本語' };
    const INITIAL_ACHIEVEMENTS = [
        { id: 'first_view', title: 'First Step', description: 'View your first mantra.', unlocked: false }, { id: '7_day_streak', title: 'Consistent Mind', description: 'View mantras for 7 days in a row.', unlocked: false }, { id: '3_mantras', title: 'Trio of Power', description: 'Select at least 3 mantras.', unlocked: false }, { id: 'custom_mantra', title: 'Your Own Voice', description: 'Create your first custom mantra.', unlocked: false }, { id: '100_views', title: 'Mantra Master', description: 'View mantras 100 times in total.', unlocked: false }, { id: 'audio_mantra', title: 'Voice of Power', description: 'Generate a mantra using your voice.', unlocked: false },
    ];
    const MAX_RECORDING_SECONDS = 30;
    const MAX_AI_RECORDING_SECONDS = 10;

    // --- AUDIO & BROWSER SUPPORT ---
    const isAudioSupported = !!(navigator.mediaDevices && window.MediaRecorder);
    let mediaRecorder = null;
    let audioChunks = [];
    let recordingTimer = null;
    let recordingInterval = null;
    let currentlyRecordingMantraId = null;
    const audioPlayer = new Audio();
    let currentlyPlayingMantraId = null;
    let audioContext;

    // AI Audio Recording Globals
    let aiTopicRecorder = null;
    let aiTopicChunks = [];
    let aiTopicRecordingTimer = null;
    let aiTopicRecordingInterval = null;


    // --- STATE MANAGEMENT ---
    let deferredInstallPrompt = null;
    let calendarViewDate = new Date(); // For stateful calendar navigation
    let myMantrasSortOrder = 'date-desc'; // For sorting 'My Mantras' view
    let slideshowTimer = null;
    let undoHistory = [];
    let redoHistory = [];
    let toastTimeout = null;
    let isRecordingAiTopic = false;


    const defaultSettings = {
        theme: 'theme-gradient-1', font: 'font-sans', isDarkMode: false,
        notifications: {
            mantras: {
                enabled: false,
                morning: { enabled: true, time: '08:00' },
                afternoon: { enabled: true, time: '13:00' },
                evening: { enabled: false, time: '19:00' }
            },
            affirmation: { enabled: false, time: '09:00' }
        },
        voiceFeatures: { enabled: true },
        celebrationSounds: { enabled: true },
        haptics: { enabled: true },
        slideshow: { enabled: false, interval: 6 }, // interval in seconds
        aiFeatures: { enabled: true },
        demoMode: { enabled: false },
        language: 'auto',
        aiSettings: {
            creativity: 'balanced', // focused, balanced, creative
            tone: 'inspirational', // inspirational, assertive, gentle, calm
            length: 'medium' // short, medium, long
        },
        audioInput: { enabled: true },
    };

    let state = {
      userMantras: [],
      userAffirmations: [],
      settings: JSON.parse(JSON.stringify(defaultSettings)), // Deep copy
      progress: {},
      isOnboardingComplete: false,
      achievements: INITIAL_ACHIEVEMENTS,
      currentMantraIndex: 0,
      onboardingTempMantras: [],
      dailyAffirmation: null,
      audioRecordings: {},
      lastDailyGoalCelebrated: null, // YYYY-MM-DD
      lastStreakMilestoneCelebrated: 0, // e.g., 7, 14, 21
      aiStatus: {
          checked: false,
          supported: false,
          text: false,
          translator: false,
          rewriter: false,
          proofreader: false,
          assistant: false,
      },
    };

    const storageKeys = {
        mantras: 'mantraos_user_mantras',
        affirmations: 'mantraos_user_affirmations',
        settings: 'mantraos_settings',
        progress: 'mantraos_progress',
        onboarding: 'mantraos_onboarding_complete',
        achievements: 'mantraos_achievements',
        dailyAffirmation: 'mantraos_daily_affirmation',
        onboardingTempMantras: 'mantraos_onboarding_temp_mantras',
        audioRecordings: 'mantraos_audio_recordings',
        lastDailyGoal: 'mantraos_last_daily_goal',
        lastStreakMilestone: 'mantraos_last_streak_milestone',
        curatedTranslations: 'mantraos_curated_translations',
    };

    function saveState() {
        try {
            localStorage.setItem(storageKeys.mantras, JSON.stringify(state.userMantras));
            localStorage.setItem(storageKeys.affirmations, JSON.stringify(state.userAffirmations));
            localStorage.setItem(storageKeys.settings, JSON.stringify(state.settings));
            localStorage.setItem(storageKeys.progress, JSON.stringify(state.progress));
            localStorage.setItem(storageKeys.onboarding, JSON.stringify(state.isOnboardingComplete));
            localStorage.setItem(storageKeys.achievements, JSON.stringify(state.achievements));
            localStorage.setItem(storageKeys.dailyAffirmation, JSON.stringify(state.dailyAffirmation));
            localStorage.setItem(storageKeys.onboardingTempMantras, JSON.stringify(state.onboardingTempMantras));
            localStorage.setItem(storageKeys.audioRecordings, JSON.stringify(state.audioRecordings));
            localStorage.setItem(storageKeys.lastDailyGoal, JSON.stringify(state.lastDailyGoalCelebrated));
            localStorage.setItem(storageKeys.lastStreakMilestone, JSON.stringify(state.lastStreakMilestoneCelebrated));
        } catch (error) {
            console.error("Failed to save state to localStorage:", error);
            if (error.name === 'QuotaExceededError') {
                 renderModal('Storage Full', 'Your device storage is full. Please clear some space, or delete some voice recordings from the settings menu.');
            }
        }
    }

    function loadState() {
        try {
            // Mantra loading with migration for priority, creation date, and text object structure
            const loadedMantras = JSON.parse(localStorage.getItem(storageKeys.mantras)) || [];
            state.userMantras = loadedMantras.map((m, index) => {
                const newMantra = { 
                    ...m, 
                    priority: m.priority || 'Medium',
                    createdAt: m.createdAt || (Date.now() - (loadedMantras.length - index) * 60000)
                };
                // Migration for new text object structure
                if (typeof newMantra.text === 'string') {
                    newMantra.text = { original: newMantra.text, translated: null };
                }
                return newMantra;
            });


            state.userAffirmations = JSON.parse(localStorage.getItem(storageKeys.affirmations)) || [];
            
            // Settings loading with migration for old notification structure
            let loadedSettings = JSON.parse(localStorage.getItem(storageKeys.settings)) || {};

            if (loadedSettings.notifications && typeof loadedSettings.notifications.enabled === 'boolean') {
                const oldNotifs = loadedSettings.notifications;
                loadedSettings.notifications = {
                    mantras: {
                        enabled: oldNotifs.enabled,
                        morning: { enabled: !!oldNotifs.morning, time: '08:00' },
                        afternoon: { enabled: !!oldNotifs.afternoon, time: '13:00' },
                        evening: { enabled: !!oldNotifs.evening, time: '19:00' },
                    },
                    affirmation: { enabled: false, time: '09:00' }
                };
            }

            // Deep merge to ensure new settings keys are added
            const deepMerge = (target, source) => {
                const output = { ...target };
                if (target && typeof target === 'object' && source && typeof source === 'object') {
                    Object.keys(source).forEach(key => {
                        if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                            if (!(key in target))
                                Object.assign(output, { [key]: source[key] });
                            else
                                output[key] = deepMerge(target[key], source[key]);
                        } else {
                            Object.assign(output, { [key]: source[key] });
                        }
                    });
                }
                return output;
            };
            
            state.settings = deepMerge(defaultSettings, loadedSettings);

            // Apply saved translations to curated mantras
            const savedCuratedTranslations = JSON.parse(localStorage.getItem(storageKeys.curatedTranslations)) || {};
            if (savedCuratedTranslations.lang === state.settings.language && savedCuratedTranslations.translations) {
                Object.entries(savedCuratedTranslations.translations).forEach(([id, text]) => {
                    const mantra = CURATED_MANTRAS.find(m => m.id === id);
                    if (mantra) mantra.text.translated = text;
                });
            }

            state.progress = JSON.parse(localStorage.getItem(storageKeys.progress)) || {};
            state.isOnboardingComplete = JSON.parse(localStorage.getItem(storageKeys.onboarding)) || false;
            state.achievements = JSON.parse(localStorage.getItem(storageKeys.achievements)) || INITIAL_ACHIEVEMENTS;
            state.dailyAffirmation = JSON.parse(localStorage.getItem(storageKeys.dailyAffirmation)) || null;
            state.onboardingTempMantras = JSON.parse(localStorage.getItem(storageKeys.onboardingTempMantras)) || [];
            state.audioRecordings = JSON.parse(localStorage.getItem(storageKeys.audioRecordings)) || {};
            state.lastDailyGoalCelebrated = JSON.parse(localStorage.getItem(storageKeys.lastDailyGoal)) || null;
            state.lastStreakMilestoneCelebrated = JSON.parse(localStorage.getItem(storageKeys.lastStreakMilestone)) || 0;
            
        } catch (error) {
            console.error("Failed to load state from localStorage:", error);
        }
    }

    // --- DOM & UTILS ---
    const root = document.getElementById('root');
    const hapticFeedback = () => {
        if (state.settings.haptics.enabled && navigator.vibrate) {
            navigator.vibrate(50);
        }
    };
    const getAudioStorageUsage = () => {
        const data = localStorage.getItem(storageKeys.audioRecordings) || '{}';
        const bytes = new Blob([data]).size;
        if (bytes < 1024) return `${bytes} B`;
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    };
    const formatDate = (d) => `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    const getNestedValue = (obj, path) => path.split('.').reduce((acc, part) => acc && acc[part], obj);
    const setNestedValue = (obj, path, value) => {
        const keys = path.split('.');
        const lastKey = keys.pop();
        const target = keys.reduce((acc, part) => acc[part] = acc[part] || {}, obj);
        target[lastKey] = value;
    };
    const getMantraText = (mantra) => {
        const targetLang = state.settings.language;
        if (targetLang !== 'en' && mantra.text.translated) {
            return mantra.text.translated;
        }
        return mantra.text.original;
    };


    // --- APP LOGIC ---
    const performAction = (action, isRedo = false) => {
        let inverseAction = null;

        switch (action.type) {
            case 'ADD_MANTRA': {
                state.userMantras.push(action.payload);
                inverseAction = { type: 'DELETE_MANTRA', payload: { id: action.payload.id } };
                break;
            }
            case 'DELETE_MANTRA': {
                const mantraIndex = state.userMantras.findIndex(m => m.id === action.payload.id);
                if (mantraIndex > -1) {
                    const deletedMantra = state.userMantras[mantraIndex];
                    state.userMantras.splice(mantraIndex, 1);
                    inverseAction = { type: 'ADD_MANTRA', payload: deletedMantra };
                }
                break;
            }
            case 'UPDATE_MANTRA': {
                const mantraIndex = state.userMantras.findIndex(m => m.id === action.payload.id);
                if (mantraIndex > -1) {
                    const oldMantra = { ...state.userMantras[mantraIndex] };
                    state.userMantras[mantraIndex] = { ...oldMantra, ...action.payload };
                    inverseAction = { type: 'UPDATE_MANTRA', payload: oldMantra };
                }
                break;
            }
            case 'ADD_AFFIRMATION': {
                state.userAffirmations.push(action.payload);
                inverseAction = { type: 'DELETE_AFFIRMATION', payload: { id: action.payload.id } };
                break;
            }
            case 'DELETE_AFFIRMATION': {
                const index = state.userAffirmations.findIndex(a => a.id === action.payload.id);
                if (index > -1) {
                    const deleted = state.userAffirmations[index];
                    state.userAffirmations.splice(index, 1);
                    inverseAction = { type: 'ADD_AFFIRMATION', payload: deleted };
                }
                break;
            }
            case 'SET_RECORDING': {
                const { mantraId, oldRecording, newRecording } = action.payload;
                state.audioRecordings[mantraId] = newRecording;
                inverseAction = { type: 'SET_RECORDING', payload: { mantraId, oldRecording: newRecording, newRecording: oldRecording } };
                break;
            }
            case 'DELETE_RECORDING': {
                 const { mantraId, recording } = action.payload;
                 delete state.audioRecordings[mantraId];
                 inverseAction = { type: 'SET_RECORDING', payload: { mantraId, oldRecording: null, newRecording: recording } };
                 break;
            }
        }
        
        saveState();
        if (!isRedo) {
            undoHistory.push(inverseAction);
            redoHistory = []; // Clear redo history on new action
            renderToast('Action completed.', true);
        }
    };

    const undo = () => {
        if (undoHistory.length > 0) {
            const lastAction = undoHistory.pop();
            redoHistory.push(lastAction); // Push the original action to redo stack
            performAction(lastAction, true); // isRedo = true to prevent re-pushing to undo stack
            renderToast('Action undone.');
            handleHashChange(); // Re-render current view
        }
    };

    const redo = () => {
        if (redoHistory.length > 0) {
            const nextAction = redoHistory.pop();
            performAction(nextAction, false); // isRedo = false to push inverse to undo stack
            renderToast('Action redone.');
            handleHashChange(); // Re-render current view
        }
    };
    
    const unlockAchievement = (id) => {
        const achievement = state.achievements.find(a => a.id === id);
        if (achievement && !achievement.unlocked) {
            achievement.unlocked = true;
            saveState();
        }
    };
    const recordMantraView = (mantraId) => {
        if (!mantraId) return;
        const today = formatDate(new Date());

        if (!state.progress[mantraId]) {
            state.progress[mantraId] = { views: 0, lastViewed: '' };
        }
        state.progress[mantraId].views += 1;
        state.progress[mantraId].lastViewed = today;
        unlockAchievement('first_view');
        const totalViews = getTotalViews();
        if (totalViews >= 100) unlockAchievement('100_views');
        if (getStreak() >= 7) unlockAchievement('7_day_streak');
        saveState();
        checkForCelebrations();
    };
    const getTotalViews = () => Object.values(state.progress).reduce((total, p) => total + p.views, 0);
    const getStreak = () => {
        const dates = [...new Set(Object.values(state.progress).map(p => p.lastViewed).filter(d => d))].sort();
        if (dates.length === 0) return 0;
        
        let streak = 0;
        const today = new Date();
        const yesterday = new Date();
        yesterday.setDate(today.getDate() - 1);
        
        const todayStr = formatDate(today);
        const yesterdayStr = formatDate(yesterday);
        
        const parseDate = (str) => {
            const [y, m, d] = str.split('-').map(Number);
            return new Date(y, m - 1, d);
        };

        if (dates[dates.length - 1] === todayStr || dates[dates.length - 1] === yesterdayStr) {
            streak = 1;
            for (let i = dates.length - 1; i > 0; i--) {
                const currentDate = parseDate(dates[i]);
                const prevDate = parseDate(dates[i - 1]);
                const diff = (currentDate.getTime() - prevDate.getTime()) / (1000 * 3600 * 24);
                if (diff === 1) {
                    streak++;
                } else {
                    break;
                }
            }
        }
        return streak;
    };
    const getLongestStreak = () => {
        const dates = [...new Set(Object.values(state.progress).map(p => p.lastViewed).filter(d => d))].sort();
        if (dates.length <= 1) return dates.length;

        let longestStreak = 1;
        let currentStreak = 1;
        
        const parseDate = (str) => {
            const [y, m, d] = str.split('-').map(Number);
            return new Date(y, m - 1, d);
        };

        for (let i = 1; i < dates.length; i++) {
            const currentDate = parseDate(dates[i]);
            const prevDate = parseDate(dates[i - 1]);
            const diff = (currentDate.getTime() - prevDate.getTime()) / (1000 * 3600 * 24);

            if (diff === 1) {
                currentStreak++;
            } else {
                currentStreak = 1;
            }
            longestStreak = Math.max(longestStreak, currentStreak);
        }
        return longestStreak;
    };
    const applySettings = () => {
        const colors = getTextColorClasses();
        document.body.className = '';
        document.body.classList.add(state.settings.theme, 'antialiased', colors.primary, 'transition-colors', 'duration-500', 'bg-[length:200%_200%]', 'animate-gradient-shift');
        document.documentElement.classList.toggle('dark', state.settings.isDarkMode);
        document.documentElement.style.setProperty('--font-family', state.settings.font === 'font-sans' ? "'Poppins', sans-serif" : "'Playfair Display', serif");
    };
    const exportUserData = () => {
        renderConfirmationModal(
            'Export Data?',
            'This will create a JSON backup of your mantras, settings, and progress.',
            () => {
                try {
                    const backupData = { ...state };
                    delete backupData.aiStatus; // Don't export runtime status
                    const jsonString = JSON.stringify(backupData, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    const timestamp = new Date().toISOString().slice(0, 10);
                    link.download = `mantraos_backup_${timestamp}.json`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    renderToast('Data exported successfully!');
                } catch (error) {
                    console.error('Failed to export data:', error);
                    renderModal('Export Error', 'An error occurred while exporting your data.');
                }
            },
            { confirmText: 'Export' }
        );
    };
    
    // --- SLIDESHOW LOGIC ---
    const stopSlideshow = () => {
        if (slideshowTimer) {
            clearTimeout(slideshowTimer);
            slideshowTimer = null;
        }
    };

    const goToNextMantra = () => {
        // DOUBLE CHECK we're still on dashboard before proceeding
        const currentPath = window.location.hash.slice(1);
        if (currentPath !== '/dashboard' && currentPath !== '') {
            stopSlideshow();
            return; // ABORT if not on dashboard
        }
        
        // Only then proceed with mantra rotation
        const newIndex = (state.currentMantraIndex + 1) % state.userMantras.length;
        state.currentMantraIndex = newIndex;
        renderTransitionParticles();

        const mantraText = document.getElementById('mantra-text');
        if (mantraText) {
            mantraText.style.opacity = '0';
            setTimeout(() => {
                renderDashboard();
            }, 150);
        } else {
            renderDashboard();
        }
        
        // Restart slideshow ONLY if still on dashboard
        startSlideshow();
    };

    const startSlideshow = () => {
        // ONLY start if user is actually on dashboard AND has multiple mantras
        const currentPath = window.location.hash.slice(1);
        if (currentPath !== '/dashboard' && currentPath !== '') {
            return; // IMMEDIATELY EXIT if not on dashboard
        }
        
        if (state.settings.slideshow.enabled && state.userMantras.length > 1) {
            stopSlideshow(); // Clear any existing timer
            slideshowTimer = setTimeout(goToNextMantra, state.settings.slideshow.interval * 1000);
        }
    };

    const resetSlideshowTimer = () => {
        stopSlideshow();
        startSlideshow();
    };

    // --- AUDIO LOGIC ---
    const playSound = (type) => {
        if (!state.settings.celebrationSounds.enabled) return;
        try {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const playNote = (freq, startTime, duration) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = freq;
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(0.5, startTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + duration);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + duration);
            };

            const now = audioContext.currentTime;
            if (type === 'daily') {
                playNote(880, now, 0.2); // A5 note
            } else if (type === 'streak') {
                playNote(523.25, now, 0.15); // C5
                playNote(659.25, now + 0.15, 0.15); // E5
                playNote(783.99, now + 0.3, 0.2); // G5
            }
        } catch (e) {
            console.error("Could not play sound:", e);
        }
    };

    const stopRecording = () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
        clearTimeout(recordingTimer);
        clearInterval(recordingInterval);
        recordingTimer = null;
        recordingInterval = null;
        startSlideshow(); // Resume slideshow after stopping recording
    };
    
    const startRecording = async (mantraId) => {
        if (currentlyRecordingMantraId) stopRecording();
        if (!audioPlayer.paused) stopPlayback();
        stopSlideshow();

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            currentlyRecordingMantraId = mantraId;
            audioChunks = [];
            
            // Re-render to show recording UI
            const currentPath = window.location.hash.slice(1);
            if(currentPath === '/dashboard') renderDashboard();
            else if(currentPath === '/library') renderLibraryContent('my-mantras');

            const options = {
                mimeType: 'audio/webm;codecs=opus',
                audioBitsPerSecond: 64000 // 64kbps, a good balance for voice
            };

            try {
                mediaRecorder = new MediaRecorder(stream, options);
            } catch (e) {
                console.warn("Opus codec or specific bitrate not supported, falling back to default.", e);
                mediaRecorder = new MediaRecorder(stream); 
            }
            
            mediaRecorder.ondataavailable = event => {
                audioChunks.push(event.data);
            };
            mediaRecorder.onstop = () => {
                const audioBlob = new Blob(audioChunks, { type: options.mimeType });
                const reader = new FileReader();
                reader.onload = () => {
                    const oldRecording = state.audioRecordings[mantraId];
                    performAction({
                        type: 'SET_RECORDING',
                        payload: { mantraId, oldRecording, newRecording: reader.result }
                    });
                    currentlyRecordingMantraId = null;
                };
                reader.readAsDataURL(audioBlob);
                stream.getTracks().forEach(track => track.stop()); // Release microphone
            };

            mediaRecorder.start();

            // Auto-stop after max duration
            recordingTimer = setTimeout(stopRecording, MAX_RECORDING_SECONDS * 1000);
            
            // Timer UI update
            let secondsRemaining = MAX_RECORDING_SECONDS;
            const timerEl = document.getElementById(`audio-timer-${mantraId}`);
            if (timerEl) timerEl.textContent = `${secondsRemaining}s left`;

            recordingInterval = setInterval(() => {
                secondsRemaining--;
                const timerEl = document.getElementById(`audio-timer-${mantraId}`);
                if (timerEl) {
                    timerEl.textContent = `${secondsRemaining}s left`;
                }
                if (secondsRemaining <= 0) {
                    clearInterval(recordingInterval);
                }
            }, 1000);

        } catch (err) {
            console.error("Error accessing microphone:", err);
            currentlyRecordingMantraId = null;
            startSlideshow(); // Resume slideshow on error to prevent UI freeze
            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                renderModal('Microphone Permission Required', 'Please allow microphone access in your browser settings to record voice mantras.');
            } else {
                renderModal('Microphone Error', 'Could not access the microphone. Please ensure your microphone is connected and try again.');
            }
        }
    };

    const stopPlayback = () => {
        audioPlayer.pause();
        audioPlayer.currentTime = 0;
        const oldPlayingId = currentlyPlayingMantraId;
        currentlyPlayingMantraId = null;

        const controls = document.getElementById(`audio-controls-${oldPlayingId}`);
        if(controls) controls.innerHTML = renderAudioInterface(oldPlayingId);
        startSlideshow(); // Resume slideshow
    };

    const playRecording = (mantraId) => {
        stopSlideshow();
        if (currentlyRecordingMantraId) stopRecording();
        if (currentlyPlayingMantraId && currentlyPlayingMantraId !== mantraId) stopPlayback();

        currentlyPlayingMantraId = mantraId;
        
        if (audioPlayer.src !== state.audioRecordings[mantraId]) {
            audioPlayer.src = state.audioRecordings[mantraId];
        }
        audioPlayer.play();
    };

    const pauseRecording = () => {
        audioPlayer.pause();
        stopSlideshow(); // Also pause slideshow
    };

    const deleteRecording = (mantraId) => {
        renderConfirmationModal('Delete Recording?', 'This will permanently remove the voice recording for this mantra.', () => {
            if(currentlyPlayingMantraId === mantraId) stopPlayback();
            performAction({
                type: 'DELETE_RECORDING',
                payload: { mantraId, recording: state.audioRecordings[mantraId] }
            });
        }, {confirmText: 'Delete', confirmVariant: 'destructive'});
    };


    // --- TEMPLATING / RENDERING ---
    const renderButton = (text, { variant = 'primary', additionalClasses = '', attributes = '' } = {}) => {
      const colors = getTextColorClasses();
      const baseClasses = 'px-6 py-3 font-semibold rounded-full transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-transparent disabled:opacity-50 disabled:cursor-not-allowed';
      const ghostHover = colors.needsDarkText ? 'hover:bg-black/10' : 'hover:bg-white/10';
      const variantClasses = {
        primary: 'bg-white text-deep-purple hover:bg-opacity-90 focus:ring-white',
        secondary: `${colors.bgMuted20} ${colors.primary} ${colors.bgHover30} ${colors.ring}`,
        ghost: `bg-transparent ${colors.primary} ${ghostHover} ${colors.ring}`,
      };
      return `<button class="${baseClasses} ${variantClasses[variant]} ${additionalClasses}" ${attributes}>${text}</button>`;
    }
    
    const renderModal = (title, content, onclose) => {
        const colors = getTextColorClasses();
        const modalId = 'app-modal';
        document.getElementById(modalId)?.remove();

        const modalHTML = `
            <div id="${modalId}" class="fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4 animate-fade-in">
                <div class="glass-card w-full max-w-sm rounded-2xl p-6 text-center animate-slide-in-up">
                    <h2 class="text-2xl font-serif mb-4">${title}</h2>
                    <div class="${colors.secondary} mb-6">${content}</div>
                    ${renderButton('Got it!', { attributes: `data-action="close-modal-by-id" data-modal-id="${modalId}"` })}
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        if (onclose) {
             document.getElementById(modalId).addEventListener('click', (e) => { 
                if(e.target.dataset.action === 'close-modal-by-id' || e.target.id === modalId) {
                    onclose();
                }
             });
        }
    };

    const renderLoadingModal = (message) => {
        const colors = getTextColorClasses();
        const modalId = 'app-loading-modal';
        document.getElementById(modalId)?.remove();
        const modalHTML = `
            <div id="${modalId}" class="fixed inset-0 bg-black/70 z-[110] flex items-center justify-center p-4 animate-fade-in">
                <div class="glass-card w-full max-w-xs rounded-2xl p-6 text-center animate-slide-in-up">
                    <div class="w-8 h-8 border-4 border-current/20 border-t-current rounded-full animate-spin mx-auto mb-4"></div>
                    <p class="${colors.secondary}">${message}</p>
                </div>
            </div>`;
        document.body.insertAdjacentHTML('beforeend', modalHTML);
    };

    const closeLoadingModal = () => {
        document.getElementById('app-loading-modal')?.remove();
    };

    const renderConfirmationModal = (title, content, onConfirm, options = {}) => {
        const colors = getTextColorClasses();
        const { confirmText = 'Confirm', confirmVariant = 'primary' } = options;
        const modalId = 'app-confirmation-modal';
        document.getElementById(modalId)?.remove();

        const confirmButtonClasses = {
            primary: '',
            destructive: '!bg-rose-600 hover:!bg-rose-700 focus:ring-rose-500 !text-white'
        };
        const titleClasses = {
            primary: '',
            destructive: 'text-rose-400'
        };

        const modalHTML = `
            <div id="${modalId}" class="fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4 animate-fade-in">
                <div class="glass-card w-full max-w-sm rounded-2xl p-6 text-center animate-slide-in-up">
                    <h2 class="text-2xl font-serif mb-4 ${titleClasses[confirmVariant] || ''}">${title}</h2>
                    <div class="${colors.secondary} mb-6">${content}</div>
                    <div class="flex gap-4 justify-center">
                        ${renderButton('Cancel', { variant: 'secondary', additionalClasses: 'flex-1', attributes: `data-action="close-modal-by-id" data-modal-id="${modalId}"` })}
                        ${renderButton(confirmText, { variant: 'primary', additionalClasses: `flex-1 ${confirmButtonClasses[confirmVariant] || ''}`, attributes: 'data-action="confirm-modal-action"' })}
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHTML);

        const modalElement = document.getElementById(modalId);
        
        const confirmAction = () => {
            if (onConfirm) onConfirm();
            modalElement.remove();
        };

        modalElement.querySelector('[data-action="confirm-modal-action"]').addEventListener('click', confirmAction);
    };

    const renderToast = (message, hasUndo = false) => {
        const container = document.getElementById('toast-container');
        if (!container) return;
        
        clearTimeout(toastTimeout);
        container.innerHTML = ''; // Clear previous toast
        const colors = getTextColorClasses();
        const toast = document.createElement('div');
        toast.className = `glass-card flex items-center justify-between p-3 rounded-xl shadow-lg animate-toast-in ${colors.primary}`;
        
        const undoButton = hasUndo ? `<button data-action="undo" class="font-bold ${colors.accent} ml-4">Undo</button>` : '';
        toast.innerHTML = `<span>${message}</span> ${undoButton}`;
        
        container.appendChild(toast);

        const removeToast = () => {
            toast.classList.remove('animate-toast-in');
            toast.classList.add('animate-toast-out');
            toast.addEventListener('animationend', () => toast.remove());
        };

        toastTimeout = setTimeout(removeToast, 4000);
    };

    // --- CELEBRATION LOGIC ---
    const renderTransitionParticles = () => {
        const container = document.getElementById('swipe-area');
        if (!container) return;

        const colors = ['#f6d365', '#4facfe', '#ffffff'];
        for (let i = 0; i < 8; i++) {
            const particle = document.createElement('div');
            particle.className = 'transition-particle';
            particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            particle.style.left = `${20 + Math.random() * 60}%`;
            particle.style.bottom = `${Math.random() * 20}%`;
            particle.style.animation = `particle-effect ${0.5 + Math.random() * 0.5}s ${Math.random() * 0.2}s ease-out forwards`;
            container.appendChild(particle);
            setTimeout(() => particle.remove(), 1000);
        }
    };

    const renderCelebrationModal = (title, description, icon) => {
        const modalId = 'celebration-modal';
        document.getElementById(modalId)?.remove();
        const colors = getTextColorClasses();

        const modalHTML = `
            <div id="${modalId}" class="fixed inset-0 bg-black/80 z-[110] flex items-center justify-center p-4 animate-fade-in overflow-hidden">
                <div id="confetti-container" class="absolute inset-0 pointer-events-none"></div>
                <div class="glass-card w-full max-w-sm rounded-2xl p-6 text-center animate-slide-in-up relative ${colors.primary}">
                    <div class="text-gold mb-4">${icon}</div>
                    <h2 class="text-3xl font-serif mb-3">${title}</h2>
                    <p class="${colors.secondary} mb-6">${description}</p>
                    ${renderButton('Awesome!', { attributes: `data-action="close-modal-by-id" data-modal-id="${modalId}"` })}
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        
        // Create and animate confetti
        const container = document.getElementById('confetti-container');
        const confettiColors = ['#f6d365', '#4facfe', '#764ba2', '#ffffff'];
        for (let i = 0; i < 100; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti-piece';
            confetti.style.left = `${Math.random() * 100}vw`;
            confetti.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
            confetti.style.animation = `confetti-fall ${2 + Math.random() * 2}s ${Math.random() * 2}s ease-out forwards`;
            confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
            container.appendChild(confetti);
        }
    };

    const triggerCelebration = (type, value) => {
        playSound(type);
        if (type === 'daily') {
            renderCelebrationModal(
                'Daily Goal Achieved!',
                "You've reviewed all your mantras for today. Incredible focus!",
                ICONS.CheckCircle({ size: 64, className: 'mx-auto' })
            );
            state.lastDailyGoalCelebrated = formatDate(new Date());
        } else if (type === 'streak') {
            renderCelebrationModal(
                `${value}-Day Streak!`,
                "Your consistency is building powerful momentum. Keep it up!",
                ICONS.Trophy({ size: 64, className: 'mx-auto' })
            );
            state.lastStreakMilestoneCelebrated = value;
        }
        saveState();
    };

    const checkForCelebrations = () => {
        const today = formatDate(new Date());

        // Check for daily goal completion
        if (state.lastDailyGoalCelebrated !== today && state.userMantras.length > 0) {
            const allMantrasViewedToday = state.userMantras.every(mantra => {
                return state.progress[mantra.id] && state.progress[mantra.id].lastViewed === today;
            });
            if (allMantrasViewedToday) {
                triggerCelebration('daily');
            }
        }
        
        // Check for streak milestone
        const streak = getStreak();
        if (streak > 0 && streak % 7 === 0 && streak !== state.lastStreakMilestoneCelebrated) {
            triggerCelebration('streak', streak);
        }
    };
    
    const renderAudioInterface = (mantraId) => {
        const colors = getTextColorClasses();
        if (!isAudioSupported) {
            return `
                <div class="flex items-center gap-2 text-sm ${colors.tertiary}" title="Your browser does not support the MediaRecorder API required for voice recording.">
                    ${ICONS.MicOff({size: 20})}
                    <span class="italic">Recording not supported</span>
                </div>
            `;
        }

        if (!state.settings.voiceFeatures.enabled) return '';
    
        const hasRecording = !!state.audioRecordings[mantraId];
        const isRecordingThis = currentlyRecordingMantraId === mantraId;
        const isPlayingThis = currentlyPlayingMantraId === mantraId && !audioPlayer.paused;
        const isPausedThis = currentlyPlayingMantraId === mantraId && audioPlayer.paused && audioPlayer.currentTime > 0;

        if (isRecordingThis) {
            return `
                <div class="flex flex-col items-center gap-3 w-full max-w-xs">
                    <div class="relative flex items-center justify-center w-20 h-20">
                        <div class="absolute w-full h-full border-2 border-rose-500 rounded-full animate-pulse-ring" style="animation-delay: 0s;"></div>
                        <div class="absolute w-full h-full border-2 border-rose-500 rounded-full animate-pulse-ring" style="animation-delay: 1s;"></div>
                        <button data-action="stop-recording" data-mantra-id="${mantraId}" class="relative z-10 p-4 bg-rose-500 rounded-full flex-shrink-0 shadow-lg text-white" aria-label="Stop recording" title="Stop recording">
                            ${ICONS.StopCircle({size: 24})}
                        </button>
                    </div>
                    <div id="audio-timer-${mantraId}" class="text-lg font-mono ${colors.secondary} font-semibold">${MAX_RECORDING_SECONDS}s left</div>
                </div>
            `;
        }
    
        if (hasRecording) {
            const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100 || 0;
            let playbackControls = '';
            
            const playButton = `<button data-action="play-voice" data-mantra-id="${mantraId}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Play recording" title="Play recording">${ICONS.Play({size: 20})}</button>`;
            const pauseButton = `<button data-action="pause-voice" data-mantra-id="${mantraId}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Pause recording" title="Pause recording">${ICONS.Pause({size: 20})}</button>`;
            const stopButton = `<button data-action="stop-voice" data-mantra-id="${mantraId}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Stop playback" title="Stop playback">${ICONS.StopCircle({size: 20})}</button>`;

            if (isPlayingThis) {
                playbackControls = `${pauseButton}${stopButton}`;
            } else if (isPausedThis) {
                playbackControls = `${playButton}${stopButton}`;
            } else { // Stopped state
                playbackControls = playButton;
            }

            return `
                <div class="flex items-center gap-2 w-full max-w-xs">
                    ${playbackControls}
                    <div class="h-1.5 ${colors.bgMuted20} rounded-full overflow-hidden flex-grow">
                        <div class="h-full bg-teal audio-progress-bar-inner" data-mantra-id="${mantraId}" style="width: ${isPausedThis || isPlayingThis ? progress : 0}%;"></div>
                    </div>
                    <button data-action="record-voice" data-mantra-id="${mantraId}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Re-record voice memo" title="Re-record your voice">${ICONS.Microphone({size: 20})}</button>
                    <button data-action="delete-voice" data-mantra-id="${mantraId}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Delete voice memo" title="Delete recording">${ICONS.Trash2({size: 20})}</button>
                </div>
            `;
        }
    
        return `
            <div class="flex items-center gap-2">
                <button data-action="record-voice" data-mantra-id="${mantraId}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Record voice memo" title="Record your voice">
                    ${ICONS.Microphone({size: 20})}
                </button>
                <span class="text-sm ${colors.tertiary}">Add Your Voice</span>
            </div>
        `;
    };

    const renderUndoRedoControls = () => {
        const canUndo = undoHistory.length > 0;
        const canRedo = redoHistory.length > 0;
        const colors = getTextColorClasses();
        return `
            <div class="flex gap-2">
                <button data-action="undo" class="p-2 rounded-full ${colors.bgMuted} ${colors.bgHover} transition-colors disabled:opacity-40 disabled:cursor-not-allowed" aria-label="Undo" title="Undo (Ctrl+Z)" ${!canUndo ? 'disabled' : ''}>
                    ${ICONS.RotateCcw({ size: 20 })}
                </button>
                <button data-action="redo" class="p-2 rounded-full ${colors.bgMuted} ${colors.bgHover} transition-colors disabled:opacity-40 disabled:cursor-not-allowed" aria-label="Redo" title="Redo (Ctrl+Y)" ${!canRedo ? 'disabled' : ''}>
                    ${ICONS.RotateCw({ size: 20 })}
                </button>
            </div>
        `;
    };

    const renderPage = (content, { showBackButton = false, showUndoRedo = false } = {}) => {
        const isAppView = !window.location.hash.includes('onboarding');
        const colors = getTextColorClasses();
        const headerContent = (showBackButton || showUndoRedo) ? `
            <header class="flex justify-between items-center mb-4">
                ${showBackButton ? `
                    <button data-action="go-back" class="inline-flex items-center gap-2 p-2 pr-4 rounded-full ${colors.bgMuted} ${colors.bgHover} transition-colors" aria-label="Go back" title="Go back">
                        ${ICONS.ArrowLeft({ size: 20 })}
                        <span class="text-sm">Back</span>
                    </button>
                ` : '<div></div>'}
                ${showUndoRedo ? renderUndoRedoControls() : ''}
            </header>
        ` : '';

        const mainAppLayout = `
            <div class="relative min-h-screen ${isAppView ? 'pb-24' : ''} animate-fade-in">
                <main class="p-4 md:p-6">${headerContent}${content}</main>
                ${isAppView ? renderBottomNav() : ''}
            </div>
        `;
        root.innerHTML = mainAppLayout;
    };
    
    // --- ONBOARDING VIEWS ---
    const renderOnboarding = (step) => {
        // Onboarding has a fixed theme, so no dynamic colors needed here.
        let content = '';
        const backButton = (path) => `
            <div class="absolute top-4 left-4">
                <button data-action="nav" data-path="${path}" class="p-2 rounded-full bg-white/20 hover:bg-white/30 transition-colors" aria-label="Go back" title="Go back">
                    ${ICONS.ArrowLeft({ size: 24 })}
                </button>
            </div>
        `;
        switch(step) {
            case 'welcome':
                content = `
                    <div class="text-center flex flex-col items-center animate-fade-in">
                        ${ICONS.Zap({ size: 64, className: "mb-4 text-gold" })}
                        <h1 class="text-4xl font-serif mb-4">Welcome to MantraOS</h1>
                        <p class="text-lg text-white/80 mb-8">Your personal space to cultivate positivity, focus, and inner strength.</p>
                        ${renderButton('Begin Your Journey', { attributes: 'data-action="nav" data-path="/onboarding/categories"'})}
                    </div>`;
                break;
            case 'categories':
                 content = `
                    ${backButton('/onboarding/welcome')}
                    <div class="text-center animate-fade-in">
                        ${ICONS.Layers({ size: 48, className: "mx-auto mb-4 text-teal" })}
                        <h2 class="text-3xl font-serif mb-4">Focus Your Intentions</h2>
                        <p class="text-white/80 mb-6">We'll start by selecting from key life areas to personalize your experience.</p>
                        <div class="flex flex-wrap justify-center gap-2 mb-8">${CATEGORIES.filter(c => c !== 'AI Generated').map(cat => `<span class="bg-white/20 px-3 py-1 rounded-full text-sm text-white">${cat}</span>`).join('')}</div>
                        ${renderButton('Choose My Mantras', { attributes: 'data-action="nav" data-path="/onboarding/mantras"'})}
                    </div>`;
                break;
            case 'mantras':
                const selectionCount = state.onboardingTempMantras.length;
                const isNextDisabled = selectionCount < 3;
                let feedbackText;
                let feedbackColorClass = 'text-white/60'; // Default color

                if (selectionCount < 3) {
                    const remaining = 3 - selectionCount;
                    feedbackText = `Please select ${remaining} more mantra${remaining > 1 ? 's' : ''}.`;
                    feedbackColorClass = 'text-yellow-300';
                } else if (selectionCount >= 3 && selectionCount < 5) {
                    const remaining = 5 - selectionCount;
                    feedbackText = `Great! You can select up to ${remaining} more or continue.`;
                    feedbackColorClass = 'text-teal-300';
                } else if (selectionCount === 5) {
                    feedbackText = `Maximum selected. You're ready to proceed!`;
                    feedbackColorClass = 'text-teal-300';
                } else {
                    feedbackText = 'Select between 3 and 5 mantras.';
                    feedbackColorClass = 'text-red-400';
                }

                content = `
                    ${backButton('/onboarding/categories')}
                    <div class="text-center w-full max-w-md mx-auto animate-fade-in" id="mantra-selection-view">
                        <h2 class="text-3xl font-serif mb-2">Select 3-5 Core Mantras</h2>
                        <p class="text-white/80 mb-6">Choose affirmations that resonate with you.</p>
                        <div class="flex flex-wrap justify-center gap-2 mb-4">
                            ${CATEGORIES.filter(c => c !== 'AI Generated').map(cat => `<button class="px-3 py-1 text-sm rounded-full transition-colors bg-white/20 text-white" data-action="filter-mantras" data-category="${cat}">${cat}</button>`).join('')}
                        </div>
                        <div class="h-64 overflow-y-auto pr-2 space-y-3 mb-6" id="mantra-list"></div>
                        ${renderButton(`Next (${selectionCount} selected)`, { attributes: `data-action="nav" data-path="/onboarding/custom" ${isNextDisabled ? 'disabled' : ''}`})}
                        <p class="text-sm mt-2 font-medium transition-colors ${feedbackColorClass}">${feedbackText}</p>
                    </div>`;
                break;
            case 'custom':
                 content = `
                    ${backButton('/onboarding/mantras')}
                    <div class="text-center max-w-md mx-auto animate-fade-in">
                        ${ICONS.Edit({ size: 48, className: "mx-auto mb-4 text-gold" })}
                        <h2 class="text-3xl font-serif mb-4">Add Your Own Voice</h2>
                        <p class="text-white/80 mb-6">Create mantras that are uniquely meaningful to you.</p>
                        <div class="space-y-4 mb-8">
                            <textarea id="custom-mantra-text" placeholder="e.g., I am a creative powerhouse." class="w-full h-24 p-3 bg-white/10 rounded-lg text-white placeholder-white/50 focus:outline-none focus:ring-2 focus:ring-white"></textarea>
                            <select id="custom-mantra-category" class="w-full p-3 bg-white/10 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-white">
                                ${CATEGORIES.filter(c => c !== 'AI Generated').map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                            </select>
                            <select id="custom-mantra-priority" class="w-full p-3 bg-white/10 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-white">
                                <option value="Medium">Medium Priority</option>
                                <option value="High">High Priority</option>
                                <option value="Low">Low Priority</option>
                            </select>
                            ${renderButton('Add Custom Mantra', { variant: 'secondary', attributes: 'data-action="add-custom-onboarding"'})}
                        </div>
                        ${renderButton('Continue', { attributes: 'data-action="nav" data-path="/onboarding/final"'})}
                    </div>`;
                break;
            case 'final':
                content = `
                    ${backButton('/onboarding/custom')}
                    <div class="text-center animate-fade-in">
                        ${ICONS.CheckCircle({ size: 64, className: "mx-auto mb-4 text-teal" })}
                        <h2 class="text-4xl font-serif mb-4">You're All Set!</h2>
                        <p class="text-lg text-white/80 mb-8">Your personalized MantraOS is ready. Begin your journey.</p>
                        ${renderButton('Enter MantraOS', { additionalClasses: 'animate-pulse', attributes: 'data-action="finish-onboarding"'})}
                    </div>`;
                break;
        }
        root.innerHTML = `<div class="min-h-screen w-full flex flex-col items-center justify-center p-4 theme-gradient-1 text-white relative">${content}</div>`;
        if (step === 'mantras') renderMantraSelectionList(CATEGORIES.filter(c => c !== 'AI Generated')[0]);
    }

    function renderMantraSelectionList(category) {
        const container = document.getElementById('mantra-list');
        if (!container) return;
        const mantras = CURATED_MANTRAS.filter(m => m.category === category);
        container.innerHTML = mantras.map(mantra => {
            const isSelected = state.onboardingTempMantras.some(m => m.id === mantra.id);
            return `
                <div class="glass-card text-left p-4 cursor-pointer border-2 ${isSelected ? 'border-teal' : 'border-transparent'}" data-action="toggle-onboarding-mantra" data-mantra-id='${mantra.id}'>
                    <div class="flex items-center justify-between">
                        <p class="pointer-events-none">"${getMantraText(mantra)}"</p>
                        ${isSelected ? ICONS.Check({ className: 'text-teal pointer-events-none', size: 20 }) : ''}
                    </div>
                </div>`;
        }).join('');
        // Highlight active category button
        document.querySelectorAll('[data-action="filter-mantras"]').forEach(btn => {
            btn.classList.toggle('bg-white', btn.dataset.category === category);
            btn.classList.toggle('text-deep-purple', btn.dataset.category === category);
            btn.classList.toggle('font-semibold', btn.dataset.category === category);
            btn.classList.toggle('bg-white/20', btn.dataset.category !== category);
        });
    }

    // --- MAIN APP VIEWS ---
    const renderBottomNav = () => {
        const colors = getTextColorClasses();
        const navItems = [
          { path: '/dashboard', label: 'Home', icon: ICONS.Home },
          { path: '/affirmations', label: 'Affirm', icon: ICONS.Smile },
          { path: '/library', label: 'Library', icon: ICONS.Library },
          { path: '/progress', label: 'Progress', icon: ICONS.BarChart2 },
          { path: '/settings', label: 'Settings', icon: ICONS.Settings },
        ];
        const currentPath = window.location.hash.slice(1) || '/dashboard';
        return `
            <nav class="fixed bottom-0 left-0 right-0 h-20 glass-card rounded-t-3xl shadow-lg z-50">
                <div class="flex justify-around items-center h-full max-w-lg mx-auto">
                ${navItems.map(({ path, label, icon }) => {
                    const isActive = currentPath.startsWith(path);
                    return `
                    <a href="#${path}" aria-label="${label}" title="${label}" class="flex flex-col items-center justify-center w-16 h-16 rounded-2xl transition-all duration-300 ${isActive ? `${colors.bgMuted20} scale-110` : `${colors.tertiary} ${colors.bgHover}`}">
                        ${icon({ size: 24 })}
                        <span class="text-xs mt-1">${label}</span>
                    </a>`
                }).join('')}
                </div>
            </nav>
        `;
    };

    const renderDashboard = () => {
        const colors = getTextColorClasses();
        // --- Daily Affirmation Logic ---
        const checkAndShowAffirmation = () => {
            const { affirmation } = state.settings.notifications;
            if (!affirmation.enabled || state.userAffirmations.length === 0) return;

            const today = new Date().toISOString().split('T')[0];
            
            if (!state.dailyAffirmation || state.dailyAffirmation.date !== today) {
                const randomAffirmation = state.userAffirmations[Math.floor(Math.random() * state.userAffirmations.length)];
                state.dailyAffirmation = { text: randomAffirmation.text, date: today, seen: false };
                saveState();
            }
            
            if (state.dailyAffirmation && !state.dailyAffirmation.seen) {
                const [hour, minute] = affirmation.time.split(':');
                const scheduledTime = new Date();
                scheduledTime.setHours(hour, minute, 0, 0);
                
                if (new Date() >= scheduledTime) {
                    renderModal('Your Daily Affirmation', `<p class="text-xl italic">"${state.dailyAffirmation.text}"</p>`, () => {
                        state.dailyAffirmation.seen = true;
                        saveState();
                        renderDashboard(); // Re-render to show affirmation on dash
                    });
                }
            }
        };
        checkAndShowAffirmation();

        let showAffirmationOnDash = false;
        if (state.dailyAffirmation) {
            const { affirmation } = state.settings.notifications;
            if (affirmation.enabled) {
                if (state.dailyAffirmation.seen) showAffirmationOnDash = true;
            } else {
                showAffirmationOnDash = true;
            }
        }
        
        const dailyAffirmationHtml = (showAffirmationOnDash && state.dailyAffirmation) ? `
            <div class="my-4 text-center animate-slide-in-up">
                <p class="text-sm font-semibold uppercase tracking-wider ${colors.secondary} mb-1">Your Daily Affirmation</p>
                <p class="text-lg italic font-sans">"${state.dailyAffirmation.text}"</p>
            </div>
        ` : '';
        // --- End Affirmation Logic ---
        
        let content;
        if (state.userMantras.length === 0) {
            content = `
                <div class="flex flex-col items-center justify-center h-[calc(100vh-10rem)] text-center">
                    ${dailyAffirmationHtml}
                    <h2 class="text-2xl font-serif mb-4">Your mantra space is empty.</h2>
                    <p class="mb-6 ${colors.secondary}">Add some mantras from the library to get started!</p>
                    <a href="#/library" aria-label="Go to Library to add mantras">${renderButton(`${ICONS.PlusCircle({className: 'inline-block mr-2', size: 20})} Go to Library`)}</a>
                </div>
            `;
        } else {
            const currentMantra = state.userMantras[state.currentMantraIndex];
            recordMantraView(currentMantra.id);
            
            const streak = getStreak();
            const streakIcon = streak > 0 ? ICONS.Zap({ size: 16, className: `inline-block ${colors.needsDarkText ? 'text-orange-500' : 'text-gold'} -mt-1 mr-1` }) : '';
            const priorityColor = PRIORITIES[currentMantra?.priority] || PRIORITIES['Medium'];

            const slideshowProgressBar = state.settings.slideshow.enabled && state.userMantras.length > 1 ? `
                <div class="w-full h-1 ${colors.bgMuted20} rounded-full overflow-hidden mt-2">
                    <div class="h-full bg-teal" style="animation: slideshow-progress ${state.settings.slideshow.interval}s linear forwards;"></div>
                </div>
            ` : '';
            
            const canRewrite = isAnyAiFeatureEnabled();
            const rephraseButton = canRewrite ? `
                <button data-action="rewrite-mantra" data-mantra-id="${currentMantra?.id}" class="absolute top-2 right-2 p-2 ${colors.bgMuted} ${colors.bgHover} rounded-full" aria-label="Rephrase this mantra using AI" title="Rephrase mantra">
                    ${ICONS.Wand2({size: 20})}
                </button>
            ` : '';

            content = `
                <div class="flex flex-col h-[calc(100vh-8rem)] justify-between">
                  <div class="flex justify-around text-center glass-card p-3 rounded-full">
                    <div><p class="text-sm ${colors.secondary}">Total Views</p><p class="font-bold text-lg">${getTotalViews()}</p></div>
                    <div><p class="text-sm ${colors.secondary}">Current Streak</p><p class="font-bold text-lg">${streakIcon}${streak} days</p></div>
                    <div><p class="text-sm ${colors.secondary}">Views Today</p><p class="font-bold text-lg">${state.progress[currentMantra?.id]?.views || 0}</p></div>
                  </div>
                  
                  ${dailyAffirmationHtml}

                  <div id="swipe-area" class="flex-grow flex items-center justify-center relative overflow-hidden">
                    ${rephraseButton}
                    <p id="mantra-text" class="text-4xl md:text-6xl font-serif text-center leading-tight animate-fade-in animate-float">"${getMantraText(currentMantra)}"</p>
                  </div>
                  <div class="text-center">
                    <div id="audio-controls-${currentMantra?.id}" class="flex justify-center mb-4">
                        ${renderAudioInterface(currentMantra?.id)}
                    </div>
                    <p class="${colors.bgMuted20} inline-flex items-center px-3 py-1 rounded-full text-sm mb-4">
                        <span class="w-2.5 h-2.5 ${priorityColor} rounded-full mr-2"></span>
                        ${currentMantra?.category}
                    </p>
                    <div class="flex justify-center mt-4 space-x-2" id="dot-indicators">
                        ${state.userMantras.map((_, index) => `<button data-action="set-mantra-index" data-index="${index}" class="w-2 h-2 rounded-full transition-colors ${state.currentMantraIndex === index ? (colors.needsDarkText ? 'bg-charcoal' : 'bg-white') : (colors.needsDarkText ? 'bg-charcoal/30' : 'bg-white/30')}" aria-label="Go to mantra ${index + 1}" title="Go to mantra ${index + 1}"></button>`).join('')}
                    </div>
                    ${slideshowProgressBar}
                  </div>
                </div>`;
        }
        renderPage(content);
        if (state.userMantras.length > 0) {
            setupSwipeListeners();
            startSlideshow();
        }
    };

    const renderAffirmations = () => {
        let content;
        const colors = getTextColorClasses();
        if (state.userAffirmations.length === 0) {
            content = `
                <div class="flex flex-col items-center justify-center h-[calc(100vh-10rem)] text-center">
                    <h2 class="text-2xl font-serif mb-4">No affirmations yet.</h2>
                    <p class="mb-6 ${colors.secondary}">Visit the library to add your first daily affirmation.</p>
                    <a href="#/library" aria-label="Go to Library to add affirmations">${renderButton(`${ICONS.PlusCircle({className: 'inline-block mr-2', size: 20})} Add Affirmation`)}</a>
                </div>
            `;
        } else {
            const randomAffirmation = state.userAffirmations[Math.floor(Math.random() * state.userAffirmations.length)];
            content = `
                <div class="flex flex-col h-[calc(100vh-12rem)] items-center justify-center text-center">
                    <h1 class="text-2xl font-serif mb-8 ${colors.secondary}">Today's Affirmation</h1>
                    <p class="text-4xl md:text-5xl font-serif leading-tight">"${randomAffirmation.text}"</p>
                </div>
            `;
        }
        renderPage(content, { showBackButton: true, showUndoRedo: false });
    };

    const renderLibrary = () => {
        const colors = getTextColorClasses();
        const content = `
            <div id="library-view">
                <h1 class="text-4xl font-serif text-center mb-6">Library</h1>
                <div class="flex justify-center mb-6 border-b-2 ${colors.border}">
                    <button data-action="library-tab" data-tab="curated" class="px-4 py-2 transition-colors border-b-2 border-teal">Discover</button>
                    <button data-action="library-tab" data-tab="my-mantras" class="px-4 py-2 transition-colors ${colors.tertiary} border-b-2 border-transparent">My Mantras (${state.userMantras.length})</button>
                    <button data-action="library-tab" data-tab="my-affirmations" class="px-4 py-2 transition-colors ${colors.tertiary} border-b-2 border-transparent">My Affirmations (${state.userAffirmations.length})</button>
                </div>
                <div id="library-content"></div>
            </div>`;
        renderPage(content, { showBackButton: true, showUndoRedo: true });
        renderLibraryContent('curated');
    };
    
    const renderLibraryContent = (tab, options = {}) => {
        const { category = CATEGORIES[0], searchTerm = '', priorityFilter = 'All' } = options;
        const container = document.getElementById('library-content');
        if (!container) return;
        const colors = getTextColorClasses();
        const showAiFeatures = isAnyAiFeatureEnabled();

        let content = '';
        if (tab === 'curated') {
            let mantras = CURATED_MANTRAS.filter(m => m.category === category);
            if (searchTerm.trim()) {
                const lowerSearchTerm = searchTerm.trim().toLowerCase();
                mantras = mantras.filter(m => getMantraText(m).toLowerCase().includes(lowerSearchTerm));
            }
            
            const aiGenerateButton = showAiFeatures ? `
                <div class="my-4 text-center">
                    ${renderButton(`${ICONS.Sparkles({className: 'inline-block mr-2', size: 20})} Generate with AI`, {
                        variant: 'secondary',
                        attributes: 'data-action="open-ai-generate-modal" title="Generate mantras with AI"'
                    })}
                </div>
            ` : '';

            content = `
                ${aiGenerateButton}
                <div class="relative mb-4">
                    <input type="search" id="mantra-search-input" value="${searchTerm}" placeholder="Search in ${category}..." class="w-full ${colors.bgMuted} rounded-full py-2 pl-10 pr-4 ${colors.placeholder} focus:outline-none focus:ring-2 ${colors.ring}">
                    <div class="absolute left-3 top-1/2 -translate-y-1/2 opacity-50">
                        ${ICONS.Search({ size: 20 })}
                    </div>
                </div>
                <div class="flex flex-wrap justify-center gap-2 mb-4">
                    ${CATEGORIES.map(cat => `<button data-action="library-filter" data-category="${cat}" class="px-3 py-1 text-sm rounded-full transition-colors ${category === cat ? 'bg-white text-deep-purple font-semibold' : `${colors.bgMuted20}`}" aria-label="Filter by ${cat}" title="Filter by ${cat}">${cat}</button>`).join('')}
                </div>
                <div class="space-y-3 max-h-[50vh] overflow-y-auto pr-2">
                ${mantras.length > 0 ? mantras.map(mantra => {
                    const isAdded = state.userMantras.some(m => m.id === mantra.id);
                    return `
                    <div class="glass-card p-4 flex justify-between items-center">
                        <p class="flex-grow">"${getMantraText(mantra)}"</p>
                        <button data-action="toggle-library-mantra" data-mantra-id='${mantra.id}' class="ml-4 p-2 rounded-full transition-colors ${isAdded ? 'bg-teal text-white' : `${colors.bgMuted20} ${colors.bgHover30}`}" aria-label="${isAdded ? 'Remove this mantra from your list' : 'Add this mantra to your list'}" title="${isAdded ? 'Remove from My Mantras' : 'Add to My Mantras'}">
                            ${isAdded ? ICONS.Check({ size: 16 }) : ICONS.Plus({ size: 16 })}
                        </button>
                    </div>`;
                }).join('') : `<div class="text-center p-8"><p class="${colors.secondary}">No mantras found for your search.</p></div>`}
                </div>
            `;
        } else if (tab === 'my-mantras') {
            if (state.userMantras.length === 0) {
                content = `<div class="text-center p-8"><p class="${colors.secondary}">You haven't added any mantras yet. Explore the 'Discover' tab!</p></div>`;
            } else {
                const priorityButtons = ['All', ...PRIORITY_LEVELS].map(p => {
                    const isActive = priorityFilter === p;
                    return `<button data-action="library-priority-filter" data-priority="${p}" class="px-3 py-1 text-sm rounded-full transition-colors ${isActive ? 'bg-white text-deep-purple font-semibold' : `${colors.bgMuted20}`}" aria-label="Filter by ${p} priority" title="Filter by ${p} priority">${p}</button>`;
                }).join('');

                const filteredMantras = priorityFilter === 'All'
                    ? state.userMantras
                    : state.userMantras.filter(m => m.priority === priorityFilter);

                const priorityValues = { 'High': 3, 'Medium': 2, 'Low': 1 };
                const sortedMantras = [...filteredMantras].sort((a, b) => {
                    switch (myMantrasSortOrder) {
                        case 'date-asc':
                            return (a.createdAt || 0) - (b.createdAt || 0);
                        case 'priority-desc':
                            return (priorityValues[b.priority] || 0) - (priorityValues[a.priority] || 0);
                        case 'priority-asc':
                            return (priorityValues[a.priority] || 0) - (priorityValues[b.priority] || 0);
                        case 'date-desc':
                        default:
                            return (b.createdAt || 0) - (a.createdAt || 0);
                    }
                });
                
                content = `
                    <div class="flex justify-between items-center mb-4">
                         <div class="flex flex-wrap gap-2">
                            ${priorityButtons}
                        </div>
                        <select id="my-mantras-sort" class="${colors.bgMuted} rounded-full py-2 px-3 focus:outline-none focus:ring-2 ${colors.ring}">
                            <option value="date-desc" ${myMantrasSortOrder === 'date-desc' ? 'selected' : ''}>Newest First</option>
                            <option value="date-asc" ${myMantrasSortOrder === 'date-asc' ? 'selected' : ''}>Oldest First</option>
                            <option value="priority-desc" ${myMantrasSortOrder === 'priority-desc' ? 'selected' : ''}>Priority (High-Low)</option>
                            <option value="priority-asc" ${myMantrasSortOrder === 'priority-asc' ? 'selected' : ''}>Priority (Low-High)</option>
                        </select>
                    </div>
                    <div class="space-y-3 max-h-[50vh] overflow-y-auto pr-2" id="my-mantras-list">
                        ${sortedMantras.map(mantra => renderMyMantraItem(mantra)).join('')}
                    </div>
                    <div class="mt-6 text-center">
                        ${renderButton(`${ICONS.Plus({className: 'inline mr-2'})} Create New Mantra`, { attributes: 'data-action="open-create-mantra-modal"' })}
                    </div>
                `;
            }
        } else if (tab === 'my-affirmations') {
            const aiAffirmationButton = `
                <div class="my-4 text-center">
                    ${renderButton(`${ICONS.Sparkles({className: 'inline-block mr-2', size: 20})} Generate Affirmations with AI`, {
                        variant: 'secondary', 
                        attributes: 'data-action="open-ai-affirmation-modal"'
                    })}
                </div>
            `;

            if (state.userAffirmations.length === 0) {
                content = `<div class="text-center p-8"><p class="${colors.secondary}">You haven't added any affirmations. Affirmations are short, positive statements you can see once daily.</p></div>`;
            } else {
                 content = `
                    <div class="space-y-3 max-h-[50vh] overflow-y-auto pr-2">
                    ${state.userAffirmations.map(affirm => `
                        <div class="glass-card p-4 flex justify-between items-center">
                            <p>"${affirm.text}"</p>
                            <button data-action="delete-affirmation" data-affirmation-id="${affirm.id}" class="ml-4 p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Delete affirmation" title="Delete affirmation">
                                ${ICONS.Trash2({size: 16})}
                            </button>
                        </div>
                    `).join('')}
                    </div>
                 `;
            }
            content += aiAffirmationButton;
            content += `
                <div class="mt-6">
                     <h3 class="text-lg font-serif text-center mb-3">Add New Affirmation</h3>
                     <div class="flex gap-2">
                        <input type="text" id="new-affirmation-input" placeholder="e.g., I am worthy of success." class="flex-grow ${colors.bgMuted} rounded-full py-2 px-4 ${colors.placeholder} focus:outline-none focus:ring-2 ${colors.ring}">
                        <button data-action="add-affirmation" class="p-3 bg-teal text-white rounded-full">${ICONS.Plus({size: 20})}</button>
                     </div>
                </div>
             `;
        }
        
        container.innerHTML = content;

        document.querySelectorAll('[data-action="library-tab"]').forEach(btn => {
            const isTabActive = btn.dataset.tab === tab;
            btn.classList.toggle('border-teal', isTabActive);
            btn.classList.toggle(colors.primary, isTabActive);
            btn.classList.toggle(colors.tertiary, !isTabActive);
            btn.classList.toggle('border-transparent', !isTabActive);
        });
    };

    const renderMyMantraItem = (mantra) => {
      const colors = getTextColorClasses();
      const priorityColor = PRIORITIES[mantra.priority] || PRIORITIES['Medium'];

      return `
          <div class="glass-card p-4 space-y-3" id="mantra-item-${mantra.id}">
              <div class="flex justify-between items-start">
                  <p class="flex-grow text-lg">"${getMantraText(mantra)}"</p>
                  <div class="flex gap-2 ml-2 flex-shrink-0">
                      <button data-action="translate-mantra" data-mantra-id="${mantra.id}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Translate mantra" title="Translate mantra with AI">
                          ${ICONS.Globe({size: 18})}
                      </button>
                      <button data-action="proofread-mantra" data-mantra-id="${mantra.id}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Proofread mantra" title="Proofread mantra with AI">
                          ${ICONS.Languages({size: 18})}
                      </button>
                      <button data-action="edit-mantra" data-mantra-id="${mantra.id}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Edit mantra" title="Edit mantra">
                          ${ICONS.Edit({size: 18})}
                      </button>
                      <button data-action="delete-mantra" data-mantra-id="${mantra.id}" class="p-2 ${colors.bgMuted20} ${colors.bgHover30} rounded-full" aria-label="Delete mantra" title="Delete mantra">
                          ${ICONS.Trash2({size: 18})}
                      </button>
                  </div>
              </div>
              <div class="flex justify-between items-end">
                  <div class="${colors.bgMuted20} inline-flex items-center px-3 py-1 rounded-full text-sm">
                      <span class="w-2.5 h-2.5 ${priorityColor} rounded-full mr-2"></span>
                      ${mantra.category} &bull; ${mantra.priority}
                  </div>
                  <div id="audio-controls-${mantra.id}">
                    ${renderAudioInterface(mantra.id)}
                  </div>
              </div>
          </div>
      `;
    };

    const renderProgress = () => {
        const colors = getTextColorClasses();
        const streak = getStreak();
        const longestStreak = getLongestStreak();
        const totalViews = getTotalViews();
        const today = formatDate(new Date());

        const calendarDays = () => {
            let daysHtml = '';
            const year = calendarViewDate.getFullYear();
            const month = calendarViewDate.getMonth();
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);

            const viewedDates = new Set(Object.values(state.progress).map(p => p.lastViewed));

            const dayOfWeek = firstDay.getDay(); // Sunday - 0, Monday - 1, etc.
            for (let i = 0; i < dayOfWeek; i++) {
                daysHtml += '<div></div>';
            }

            for (let day = 1; day <= lastDay.getDate(); day++) {
                const dateStr = formatDate(new Date(year, month, day));
                const isViewed = viewedDates.has(dateStr);
                const isToday = dateStr === today;
                daysHtml += `<div class="h-10 flex items-center justify-center rounded-full ${isViewed ? 'bg-teal text-white font-bold' : ''} ${isToday && !isViewed ? `ring-2 ${colors.needsDarkText ? 'ring-charcoal' : 'ring-white'}` : ''}">${day}</div>`;
            }
            return daysHtml;
        };
        
        const unlockedAchievements = state.achievements.filter(a => a.unlocked);

        const content = `
            <h1 class="text-4xl font-serif text-center mb-6">Your Progress</h1>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                <div class="glass-card p-4 text-center rounded-2xl">
                    <p class="text-3xl font-bold">${streak}</p>
                    <p class="${colors.secondary}">Day Streak</p>
                </div>
                 <div class="glass-card p-4 text-center rounded-2xl">
                    <p class="text-3xl font-bold">${longestStreak}</p>
                    <p class="${colors.secondary}">Longest Streak</p>
                </div>
                <div class="glass-card p-4 text-center rounded-2xl">
                    <p class="text-3xl font-bold">${totalViews}</p>
                    <p class="${colors.secondary}">Total Views</p>
                </div>
                <div class="glass-card p-4 text-center rounded-2xl">
                    <p class="text-3xl font-bold">${state.userMantras.length}</p>
                    <p class="${colors.secondary}">Active Mantras</p>
                </div>
            </div>

            <div class="glass-card p-4 rounded-2xl mb-8">
                <div class="flex justify-between items-center mb-4">
                    <button data-action="prev-month" class="p-2 rounded-full ${colors.bgMuted} ${colors.bgHover}" aria-label="Previous month">${ICONS.ArrowLeft({})}</button>
                    <h2 class="text-xl font-serif">${calendarViewDate.toLocaleString('default', { month: 'long', year: 'numeric' })}</h2>
                    <button data-action="next-month" class="p-2 rounded-full ${colors.bgMuted} ${colors.bgHover}" aria-label="Next month">${ICONS.ArrowRight({})}</button>
                </div>
                <div class="grid grid-cols-7 gap-2 text-center text-sm ${colors.secondary}">
                    <div>S</div><div>M</div><div>T</div><div>W</div><div>T</div><div>F</div><div>S</div>
                </div>
                <div class="grid grid-cols-7 gap-2 mt-2" id="calendar-grid">
                    ${calendarDays()}
                </div>
            </div>

            <div>
                 <h2 class="text-2xl font-serif text-center mb-4">Achievements (${unlockedAchievements.length}/${state.achievements.length})</h2>
                 <div class="space-y-3">
                    ${state.achievements.map(a => `
                        <div class="glass-card p-4 flex items-center gap-4 rounded-xl transition-opacity ${a.unlocked ? 'opacity-100' : 'opacity-50'}">
                            <div class="${a.unlocked ? 'text-gold' : colors.secondary}">${ICONS.Award({size: 32})}</div>
                            <div>
                                <h3 class="font-bold">${a.title}</h3>
                                <p class="text-sm ${colors.secondary}">${a.description}</p>
                            </div>
                        </div>
                    `).join('')}
                 </div>
            </div>
        `;
        renderPage(content, { showBackButton: true });
    };

    const renderSettings = () => {
        const colors = getTextColorClasses();
        const settings = state.settings;
        const toggle = (path, label) => {
            const isChecked = getNestedValue(settings, path);
            return `
                <label class="flex justify-between items-center cursor-pointer">
                    <span>${label}</span>
                    <div class="relative">
                        <input type="checkbox" data-setting="${path}" class="sr-only peer" ${isChecked ? 'checked' : ''}>
                        <div class="w-11 h-6 ${colors.bgMuted20} rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:border-gray-300 after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-teal"></div>
                    </div>
                </label>
            `;
        };
        
        const aiStatusIndicator = (status) => {
            const icon = status ? ICONS.CheckCircle({ size: 16, className: 'text-teal-400' }) : ICONS.XCircle({ size: 16, className: 'text-rose-400' });
            return `<span class="ml-2">${icon}</span>`;
        };
        
        const content = `
            <h1 class="text-4xl font-serif text-center mb-6">Settings</h1>
            <div class="space-y-6 max-w-2xl mx-auto">
                <div class="glass-card p-4 rounded-2xl">
                    <h2 class="text-xl font-serif mb-3">Appearance</h2>
                    <div class="space-y-3">
                        <div>
                            <p class="mb-2">Theme</p>
                            <div class="grid grid-cols-2 gap-2">
                                ${THEME_OPTIONS.map(theme => `
                                    <button data-setting="theme" data-value="${theme.id}" class="w-full p-2 rounded-lg text-left border-2 ${settings.theme === theme.id ? 'border-teal' : colors.border}">
                                        <div class="w-full h-8 rounded" style="background: ${theme.gradient};"></div>
                                        <p class="mt-1 text-sm">${theme.name}</p>
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                         <div>
                            <p class="mb-2">Font</p>
                            <div class="flex gap-2">
                                ${FONT_OPTIONS.map(font => `
                                     <button data-setting="font" data-value="${font.id}" class="flex-1 p-3 rounded-lg text-center ${font.id === 'font-serif' ? 'font-serif' : ''} ${settings.font === font.id ? `bg-white ${colors.needsDarkText ? 'text-charcoal' : 'text-deep-purple'}` : colors.bgMuted20}">${font.name}</button>
                                `).join('')}
                            </div>
                        </div>
                        ${toggle('isDarkMode', 'Dark Mode')}
                         <div>
                             <p class="mb-2">Language</p>
                             <select data-setting="language" class="w-full p-3 ${colors.bgMuted} rounded-lg focus:outline-none focus:ring-2 ${colors.ring}">
                                <option value="auto">Auto-detect</option>
                                ${Object.entries(SUPPORTED_LANGUAGES).map(([code, name]) => `<option value="${code}" ${settings.language === code ? 'selected' : ''}>${name}</option>`).join('')}
                             </select>
                         </div>
                    </div>
                </div>

                <div class="glass-card p-4 rounded-2xl">
                     <h2 class="text-xl font-serif mb-3">Features</h2>
                     <div class="space-y-3">
                         ${toggle('voiceFeatures.enabled', 'Voice Recording')}
                         ${toggle('celebrationSounds.enabled', 'Celebration Sounds')}
                         ${toggle('haptics.enabled', 'Haptic Feedback')}
                         <div class="flex justify-between items-center">
                            <span>Slideshow Speed</span>
                             <div class="flex items-center gap-2">
                                <span class="text-sm">Slow</span>
                                <input type="range" min="3" max="15" value="${settings.slideshow.interval}" data-setting="slideshow.interval" class="w-24 ${colors.accentCheckbox}">
                                <span class="text-sm">Fast</span>
                            </div>
                         </div>
                         ${toggle('slideshow.enabled', 'Enable Slideshow')}
                     </div>
                </div>
                
                <div class="glass-card p-4 rounded-2xl">
                     <h2 class="text-xl font-serif mb-3 flex items-center">
                        AI Diagnostics ${ICONS.Cpu({size: 20, className: 'inline ml-2'})}
                        <button data-action="rerun-ai-check" class="ml-auto p-2 ${colors.bgMuted} ${colors.bgHover} rounded-full" title="Rerun Diagnostics">${ICONS.RotateCw({size: 16})}</button>
                     </h2>
                     <div class="space-y-2 text-sm ${colors.secondary}">
                        <div class="flex justify-between"><span>Browser Support (window.ai)</span> ${aiStatusIndicator(state.aiStatus.supported)}</div>
                        <div class="flex justify-between"><span>Text Generation</span> ${aiStatusIndicator(state.aiStatus.text)}</div>
                        <div class="flex justify-between"><span>Translation</span> ${aiStatusIndicator(state.aiStatus.translator)}</div>
                        <div class="flex justify-between"><span>Audio Assistant</span> ${aiStatusIndicator(state.aiStatus.assistant)}</div>
                     </div>
                     <div class="mt-4 space-y-3">
                         ${toggle('aiFeatures.enabled', 'Enable On-Device AI')}
                         ${toggle('demoMode.enabled', 'Enable Demo Mode')}
                         <p class="text-xs ${colors.tertiary}">Enable demo mode if on-device AI is not available on your system.</p>
                     </div>
                </div>

                <div class="glass-card p-4 rounded-2xl">
                     <h2 class="text-xl font-serif mb-3">Data Management</h2>
                     <div class="grid grid-cols-2 gap-3">
                        <button data-action="export-data" class="w-full p-3 rounded-lg ${colors.bgMuted20} ${colors.bgHover30} flex items-center justify-center gap-2">${ICONS.Download({size: 18})} Export</button>
                        <button data-action="import-data" class="w-full p-3 rounded-lg ${colors.bgMuted20} ${colors.bgHover30} flex items-center justify-center gap-2">${ICONS.Upload({size: 18})} Import</button>
                     </div>
                     <div class="mt-4">
                        <button data-action="reset-app" class="w-full p-3 rounded-lg bg-rose-500/20 hover:bg-rose-500/30 text-rose-300">Reset Application</button>
                     </div>
                     <div class="mt-4 flex justify-between items-center">
                         <p class="text-sm">Voice Storage: <span class="font-semibold">${getAudioStorageUsage()}</span></p>
                         <button data-action="clear-audio" class="text-sm text-rose-400 hover:underline">Clear All</button>
                     </div>
                </div>
            </div>
        `;

        renderPage(content, { showBackButton: true });
    };
    
    // --- AI MODALS AND HANDLERS ---
    const renderAiAffirmationModal = () => {
        const colors = getTextColorClasses();
        const modalId = 'ai-affirmation-modal';
        document.getElementById(modalId)?.remove();

        const modalHTML = `
            <div id="${modalId}" class="fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4 animate-fade-in">
                <div class="glass-card w-full max-w-md rounded-2xl p-6 animate-slide-in-up">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-serif">Generate Affirmations</h2>
                        <button data-action="close-modal-by-id" data-modal-id="${modalId}" class="p-2 ${colors.bgMuted} ${colors.bgHover} rounded-full">&times;</button>
                    </div>
                    <p class="${colors.secondary} mb-4">Enter a topic, and the on-device AI will create affirmations for you.</p>
                    
                    <div class="flex gap-2 mb-4">
                        <input type="text" id="ai-affirmation-topic" placeholder="e.g., Confidence, Calm, Success" class="flex-grow ${colors.bgMuted} rounded-full py-2 px-4 ${colors.placeholder} focus:outline-none focus:ring-2 ${colors.ring}">
                        <button data-action="generate-ai-affirmations" class="p-3 bg-teal text-white rounded-full">${ICONS.Sparkles({size: 20})}</button>
                    </div>
                    
                    <div id="ai-affirmation-results" class="space-y-2 max-h-60 overflow-y-auto pr-2">
                        <!-- Results will be injected here -->
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHTML);
    };

    const renderTranslateModal = (mantra) => {
        const colors = getTextColorClasses();
        const modalId = 'translate-mantra-modal';
        document.getElementById(modalId)?.remove();

        const languageOptions = Object.entries(SUPPORTED_LANGUAGES).map(([code, name]) => 
            `<option value="${code}" ${state.settings.language === code ? 'selected' : ''}>${name}</option>`
        ).join('');

        const modalHTML = `
            <div id="${modalId}" class="fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4 animate-fade-in">
                <div class="glass-card w-full max-w-md rounded-2xl p-6 animate-slide-in-up">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-serif">Translate Mantra</h2>
                        <button data-action="close-modal-by-id" data-modal-id="${modalId}" class="p-2 ${colors.bgMuted} ${colors.bgHover} rounded-full">&times;</button>
                    </div>
                    <p class="${colors.secondary} mb-2">Original:</p>
                    <p class="italic p-3 ${colors.bgMuted} rounded-lg mb-4">"${mantra.text.original}"</p>
                    
                    <div class="flex gap-2 mb-4">
                        <select id="translate-language-select" class="flex-grow ${colors.bgMuted} rounded-full py-2 px-4 focus:outline-none focus:ring-2 ${colors.ring}">${languageOptions}</select>
                        <button data-action="perform-translation" data-mantra-id="${mantra.id}" class="p-3 bg-teal text-white rounded-full">${ICONS.Globe({size: 20})}</button>
                    </div>

                    <div id="translation-result-container" class="hidden">
                         <p class="${colors.secondary} mb-2">Translation:</p>
                         <p id="translation-result-text" class="italic p-3 ${colors.bgMuted} rounded-lg mb-4"></p>
                         <div class="text-right">
                            ${renderButton('Save Translation', { attributes: `data-action="save-translation" data-mantra-id="${mantra.id}"`})}
                         </div>
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHTML);
    };

    const renderAiGenerateModal = () => {
        const colors = getTextColorClasses();
        const modalId = 'ai-generate-mantra-modal';
        document.getElementById(modalId)?.remove();

        let micButtonHTML;
        if(isRecordingAiTopic) {
            micButtonHTML = `
                <div id="ai-mic-button-container" class="flex items-center gap-2">
                    <button id="ai-mic-button" data-action="stop-ai-topic-recording" class="p-3 bg-rose-500 text-white rounded-full animate-pulse" aria-label="Stop recording topic" title="Stop recording">
                        ${ICONS.StopCircle({size: 20})}
                    </button>
                    <span id="ai-recording-timer" class="font-mono text-sm ${colors.secondary}"></span>
                </div>
            `;
        } else {
            micButtonHTML = `
                <div id="ai-mic-button-container">
                    <button id="ai-mic-button" data-action="start-ai-topic-recording" class="p-3 bg-teal text-white rounded-full" aria-label="Use microphone to provide topic" title="Use microphone">
                        ${ICONS.Microphone({size: 20})}
                    </button>
                </div>
            `;
        }

        const modalHTML = `
            <div id="${modalId}" class="fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4 animate-fade-in">
                <div class="glass-card w-full max-w-md rounded-2xl p-6 animate-slide-in-up">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-serif">Generate with AI</h2>
                        <button data-action="close-modal-by-id" data-modal-id="${modalId}" class="p-2 ${colors.bgMuted} ${colors.bgHover} rounded-full" aria-label="Close">&times;</button>
                    </div>
                    <p class="${colors.secondary} mb-4">Enter a topic below, or use the microphone to speak your intention.</p>
                    
                    <div class="flex gap-2 mb-4">
                        <input type="text" id="ai-generate-topic" placeholder="e.g., Confidence, Calmness" class="flex-grow ${colors.bgMuted} rounded-full py-2 px-4 ${colors.placeholder} focus:outline-none focus:ring-2 ${colors.ring}">
                        ${micButtonHTML}
                    </div>
                    
                    <div class="text-center mb-4">
                        ${renderButton(`${ICONS.Sparkles({className: 'inline-block mr-2', size: 20})} Generate Mantras`, { attributes: 'data-action="generate-ai-mantras"' })}
                    </div>

                    <div id="ai-generate-results" class="space-y-2 max-h-60 overflow-y-auto pr-2">
                        <!-- Results will be injected here -->
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHTML);
    };

    const handleGenerateAiMantras = async () => {
        const topicInput = document.getElementById('ai-generate-topic');
        const topic = topicInput.value.trim();
        if (!topic) {
            renderToast('Please enter or speak a topic.');
            return;
        }

        const resultsContainer = document.getElementById('ai-generate-results');
        resultsContainer.innerHTML = `<div class="flex justify-center p-4"><div class="w-6 h-6 border-4 border-current/20 border-t-current rounded-full animate-spin"></div></div>`;
        
        let mantras = [];
        if (isAnyAiFeatureEnabled() && state.aiStatus.text) {
            try {
                if (!aiTextSession) aiTextSession = await window.ai.createTextSession();
                const { creativity, tone, length } = state.settings.aiSettings;
                const prompt = `You are an expert in crafting positive affirmations. Generate 5 unique, powerful, first-person mantras about "${topic}". The tone should be ${tone} and the length should be ${length}. Creativity level: ${creativity}. Return only a JSON array of strings, like ["I am...", "I will..."]. Do not include any other text or markdown.`;
                const result = await aiTextSession.prompt(prompt);
                mantras = JSON.parse(result.match(/\[.*\]/s)[0]); // Loosely parse JSON from a potentially messy string
            } catch (e) {
                console.error('AI Mantra Generation Error:', e);
                mantras = [`[Demo] I am successful and confident, inspired by ${topic}.`, `[Demo] I embrace the calm and peace that ${topic} brings.`];
                renderToast('AI failed. Showing demo results.');
            }
        } else {
            await new Promise(r => setTimeout(r, 1000));
            mantras = [`[Demo] I am a master of ${topic}.`, `[Demo] My life is full of ${topic}.`, `[Demo] I attract positive ${topic} into my life.`];
        }
        
        resultsContainer.innerHTML = mantras.map(mantra => {
            const isAdded = state.userMantras.some(m => m.text.original.toLowerCase() === mantra.toLowerCase());
            const disabled = isAdded ? 'disabled' : '';
            const icon = isAdded ? ICONS.Check({size: 16}) : ICONS.Plus({size: 16});
            return `<div class="glass-card p-3 flex justify-between items-center">
                        <span>"${mantra}"</span>
                        <button data-action="add-generated-mantra" data-text="${encodeURIComponent(mantra)}" class="p-2 bg-teal text-white rounded-full ${isAdded ? 'opacity-50' : ''}" ${disabled}>
                            ${icon}
                        </button>
                    </div>`;
        }).join('');
    };

    const handleGenerateAiAffirmations = async () => {
        const topicInput = document.getElementById('ai-affirmation-topic');
        const topic = topicInput.value.trim();
        if (!topic) {
            renderToast('Please enter a topic.');
            return;
        }

        const resultsContainer = document.getElementById('ai-affirmation-results');
        resultsContainer.innerHTML = `<div class="flex justify-center p-4"><div class="w-6 h-6 border-4 border-current/20 border-t-current rounded-full animate-spin"></div></div>`;
        
        let affirmations = [];
        if (isAnyAiFeatureEnabled() && state.aiStatus.text) {
            try {
                if (!aiTextSession) aiTextSession = await window.ai.createTextSession();
                const prompt = `Generate 5 short, positive, first-person affirmations about "${topic}". Return only a JSON array of strings, like ["I am...", "I will..."].`;
                const result = await aiTextSession.prompt(prompt);
                affirmations = JSON.parse(result);
            } catch (e) {
                console.error('AI Affirmation Generation Error:', e);
                affirmations = [`[Demo] I am successful and confident, inspired by ${topic}.`, `[Demo] I embrace the calm and peace that ${topic} brings.`];
                renderToast('AI failed. Showing demo results.');
            }
        } else {
            await new Promise(r => setTimeout(r, 1000)); // Simulate network
            affirmations = [`[Demo] I am a master of ${topic}.`, `[Demo] My life is full of ${topic}.`, `[Demo] I attract positive ${topic} into my life.`];
        }
        
        resultsContainer.innerHTML = affirmations.map(aff => {
            return `<div class="glass-card p-3 flex justify-between items-center"><span>"${aff}"</span><button data-action="add-generated-affirmation" data-text="${encodeURIComponent(aff)}" class="p-2 bg-teal text-white rounded-full">${ICONS.Plus({size: 16})}</button></div>`;
        }).join('');
    };

    const handlePerformTranslation = async (mantraId) => {
        const select = document.getElementById('translate-language-select');
        const targetLang = select.value;
        const mantra = state.userMantras.find(m => m.id === mantraId) || CURATED_MANTRAS.find(m => m.id === mantraId);
        if (!mantra) return;

        const resultContainer = document.getElementById('translation-result-container');
        const resultTextEl = document.getElementById('translation-result-text');
        resultContainer.classList.remove('hidden');
        resultTextEl.innerHTML = `<div class="flex justify-center p-2"><div class="w-5 h-5 border-2 border-current/20 border-t-current rounded-full animate-spin"></div></div>`;
        
        let translatedText = '';
        if (isAnyAiFeatureEnabled() && state.aiStatus.translator) {
            try {
                if (!aiTranslator) aiTranslator = await window.ai.translator.create();
                const result = await aiTranslator.translate(mantra.text.original, 'en', targetLang);
                translatedText = result.translatedText;
            } catch (e) {
                console.error("AI Translation Error:", e);
                translatedText = `[Demo] Translation of "${mantra.text.original}" to ${targetLang}.`;
                renderToast('AI failed. Showing demo result.');
            }
        } else {
            await new Promise(r => setTimeout(r, 1000)); // Simulate network
            translatedText = `[Demo] Translation of "${mantra.text.original}" to ${targetLang}.`;
        }

        resultTextEl.textContent = `"${translatedText}"`;
        // Store it temporarily for saving
        resultTextEl.dataset.translatedText = translatedText;
    };

    const handleSaveTranslation = (mantraId) => {
        const resultTextEl = document.getElementById('translation-result-text');
        const translatedText = resultTextEl.dataset.translatedText;

        if (!translatedText) return;

        const targetLang = document.getElementById('translate-language-select').value;
        
        // Check if it's a curated mantra or user mantra
        const curatedMantra = CURATED_MANTRAS.find(m => m.id === mantraId);
        if (curatedMantra) {
            curatedMantra.text.translated = translatedText;
            // Save to a separate localStorage item for curated translations
            const savedCuratedTranslations = JSON.parse(localStorage.getItem(storageKeys.curatedTranslations)) || { lang: null, translations: {} };
            savedCuratedTranslations.lang = targetLang;
            savedCuratedTranslations.translations[mantraId] = translatedText;
            localStorage.setItem(storageKeys.curatedTranslations, JSON.stringify(savedCuratedTranslations));
        } else {
            const userMantraIndex = state.userMantras.findIndex(m => m.id === mantraId);
            if (userMantraIndex > -1) {
                state.userMantras[userMantraIndex].text.translated = translatedText;
            }
        }
        
        saveState();
        document.getElementById('translate-mantra-modal')?.remove();
        renderToast('Translation saved!');
        // Re-render the view to show the new text
        const currentPath = window.location.hash.slice(1);
        if (currentPath.startsWith('/library')) {
            renderLibraryContent('my-mantras');
        } else if (currentPath.startsWith('/dashboard')) {
            renderDashboard();
        }
    };
    
    const stopAiTopicRecording = () => {
        if (aiTopicRecorder && aiTopicRecorder.state === 'recording') {
            aiTopicRecorder.stop();
        }
        clearTimeout(aiTopicRecordingTimer);
        clearInterval(aiTopicRecordingInterval);
        aiTopicRecordingTimer = null;
        aiTopicRecordingInterval = null;
        isRecordingAiTopic = false;
    };

    const startAiTopicRecording = async () => {
        if (!isAnyAiFeatureEnabled() || !state.aiStatus.assistant) {
            renderToast('AI audio input is not available.');
            return;
        }
        if (isRecordingAiTopic) stopAiTopicRecording();

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            isRecordingAiTopic = true;
            aiTopicChunks = [];
            renderAiGenerateModal(); // Re-render to show recording UI

            aiTopicRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

            aiTopicRecorder.ondataavailable = event => {
                aiTopicChunks.push(event.data);
            };
            
            aiTopicRecorder.onstop = async () => {
                const audioBlob = new Blob(aiTopicChunks, { type: 'audio/webm' });
                stream.getTracks().forEach(track => track.stop());

                const topicInput = document.getElementById('ai-generate-topic');
                const micButton = document.getElementById('ai-mic-button');
                const micButtonContainer = document.getElementById('ai-mic-button-container');
                const colors = getTextColorClasses();

                if (topicInput) topicInput.placeholder = 'Transcribing...';
                if (micButton) micButton.innerHTML = `<div class="w-5 h-5 border-2 border-current/20 border-t-current rounded-full animate-spin"></div>`;

                try {
                    const audioBuffer = await audioBlob.arrayBuffer();
                    const result = await window.ai.assistant.prompt({ audio: audioBuffer });
                    if (topicInput) {
                        topicInput.value = result;
                        topicInput.placeholder = 'e.g., Confidence, Calmness';
                    }
                    unlockAchievement('audio_mantra');
                    renderToast('Transcription complete!');
                } catch (e) {
                    console.error("AI Transcription error:", e);
                    renderToast('Could not transcribe audio.');
                    if (topicInput) topicInput.placeholder = 'e.g., Confidence, Calmness';
                } finally {
                    if (micButtonContainer) {
                        // Restore original mic button
                        micButtonContainer.innerHTML = `
                            <button id="ai-mic-button" data-action="start-ai-topic-recording" class="p-3 bg-teal text-white rounded-full" aria-label="Use microphone to provide topic" title="Use microphone">
                                ${ICONS.Microphone({size: 20})}
                            </button>
                        `;
                    }
                }
            };

            aiTopicRecorder.start();
            
            // Auto-stop
            aiTopicRecordingTimer = setTimeout(stopAiTopicRecording, MAX_AI_RECORDING_SECONDS * 1000);
            
            // UI Timer update
            let secondsRemaining = MAX_AI_RECORDING_SECONDS;
            const timerEl = document.getElementById('ai-recording-timer');
            if (timerEl) timerEl.textContent = `${secondsRemaining}s`;

            aiTopicRecordingInterval = setInterval(() => {
                secondsRemaining--;
                const timerEl = document.getElementById('ai-recording-timer');
                if (timerEl) timerEl.textContent = `${secondsRemaining}s`;
                if (secondsRemaining <= 0) clearInterval(aiTopicRecordingInterval);
            }, 1000);

        } catch (err) {
            console.error("Error accessing microphone for AI:", err);
            isRecordingAiTopic = false;
            renderAiGenerateModal(); // Re-render to show idle state
            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                renderModal('Microphone Permission Required', 'Please allow microphone access to use this feature.');
            } else {
                renderModal('Microphone Error', 'Could not access the microphone.');
            }
        }
    };

    // --- APP ROUTING & INITIALIZATION ---
    const handleHashChange = () => {
        const path = window.location.hash.slice(1) || '/';
        
        // STOP SLIDESHOW & AUDIO ON EVERY PAGE CHANGE
        stopSlideshow();
        stopPlayback();
        
        if (!state.isOnboardingComplete && !path.startsWith('/onboarding')) {
            window.location.hash = '/onboarding/welcome';
            return;
        }

        if (path.startsWith('/onboarding')) {
            renderOnboarding(path.split('/')[2] || 'welcome');
        } else {
            applySettings();
            switch (path) {
                case '/library': renderLibrary(); break;
                case '/progress': renderProgress(); break;
                case '/settings': renderSettings(); break;
                case '/affirmations': renderAffirmations(); break;
                case '/dashboard': 
                case '/':
                    renderDashboard(); 
                    // ONLY start after dashboard is fully rendered
                    setTimeout(startSlideshow, 100);
                    break;
                default:
                    window.location.hash = '/dashboard';
            }
        }
    };

    const setupSwipeListeners = () => {
        const swipeArea = document.getElementById('swipe-area');
        if (!swipeArea) return;

        let touchStartX = 0;
        let touchEndX = 0;

        const handleSwipe = () => {
            stopSlideshow();
            const threshold = 50; // min swipe distance
            if (touchEndX < touchStartX - threshold) { // Swiped left
                goToNextMantra();
            }
            if (touchEndX > touchStartX + threshold) { // Swiped right
                const newIndex = (state.currentMantraIndex - 1 + state.userMantras.length) % state.userMantras.length;
                state.currentMantraIndex = newIndex;
                renderTransitionParticles();
                
                const mantraText = document.getElementById('mantra-text');
                if (mantraText) {
                    mantraText.style.opacity = '0';
                    setTimeout(renderDashboard, 150);
                } else {
                    renderDashboard();
                }
            }
        };

        swipeArea.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        }, { passive: true });

        swipeArea.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        }, { passive: true });
    };

    const setupEventListeners = () => {
        document.body.addEventListener('click', e => {
            const target = e.target.closest('[data-action]');
            if (!target) return;
            
            hapticFeedback();
            const action = target.dataset.action;
            const mantraId = target.dataset.mantraId;

            switch(action) {
                // Navigation
                case 'nav': window.location.hash = target.dataset.path; break;
                case 'go-back': window.history.back(); break;

                // Modals
                case 'close-modal-by-id': document.getElementById(target.dataset.modalId)?.remove(); break;
                case 'open-create-mantra-modal': renderCreateEditMantraModal(); break;
                case 'edit-mantra': {
                    const mantraToEdit = state.userMantras.find(m => m.id === mantraId);
                    if (mantraToEdit) renderCreateEditMantraModal(mantraToEdit);
                    break;
                }
                case 'submit-mantra-form': handleMantraFormSubmit(target.dataset.mantraId); break;
                
                // Onboarding
                case 'finish-onboarding':
                    state.isOnboardingComplete = true;
                    state.userMantras = [...state.onboardingTempMantras];
                    if (state.userMantras.length >= 3) unlockAchievement('3_mantras');
                    if (state.userMantras.some(m => m.isCustom)) unlockAchievement('custom_mantra');
                    state.onboardingTempMantras = [];
                    saveState();
                    window.location.hash = '/dashboard';
                    break;
                case 'filter-mantras': renderMantraSelectionList(target.dataset.category); break;
                case 'toggle-onboarding-mantra': {
                    const mantra = CURATED_MANTRAS.find(m => m.id === mantraId);
                    const index = state.onboardingTempMantras.findIndex(m => m.id === mantraId);
                    if (index > -1) {
                        state.onboardingTempMantras.splice(index, 1);
                    } else if (state.onboardingTempMantras.length < 5) {
                        state.onboardingTempMantras.push({ ...mantra, createdAt: Date.now(), priority: 'Medium' });
                    }
                    saveState();
                    renderOnboarding('mantras');
                    break;
                }
                case 'add-custom-onboarding': {
                    const text = document.getElementById('custom-mantra-text').value.trim();
                    if (text) {
                        const newMantra = {
                            id: `custom_${Date.now()}`,
                            text: { original: text, translated: null },
                            category: document.getElementById('custom-mantra-category').value,
                            priority: document.getElementById('custom-mantra-priority').value,
                            createdAt: Date.now(),
                            isCustom: true,
                        };
                        state.onboardingTempMantras.push(newMantra);
                        saveState();
                        renderToast('Custom mantra added!');
                        document.getElementById('custom-mantra-text').value = '';
                    } else {
                        renderToast('Please enter text for your mantra.');
                    }
                    break;
                }
                
                // Library & Affirmations
                case 'library-tab': renderLibraryContent(target.dataset.tab); break;
                case 'library-filter': renderLibraryContent('curated', { category: target.dataset.category }); break;
                case 'library-priority-filter': renderLibraryContent('my-mantras', { priorityFilter: target.dataset.priority }); break;
                case 'toggle-library-mantra': {
                    const mantra = CURATED_MANTRAS.find(m => m.id === mantraId);
                    const isAdded = state.userMantras.some(m => m.id === mantraId);
                    if (isAdded) {
                        performAction({ type: 'DELETE_MANTRA', payload: { id: mantraId } });
                    } else {
                        performAction({ type: 'ADD_MANTRA', payload: { ...mantra, createdAt: Date.now(), priority: 'Medium' } });
                    }
                    if (state.userMantras.length >= 3) unlockAchievement('3_mantras');
                    renderLibraryContent('curated', { category: mantra.category });
                    break;
                }
                case 'delete-mantra':
                    renderConfirmationModal('Delete Mantra?', 'This action cannot be undone.', () => {
                         performAction({ type: 'DELETE_MANTRA', payload: { id: mantraId } });
                         renderLibraryContent('my-mantras');
                    }, { confirmText: 'Delete', confirmVariant: 'destructive' });
                    break;
                case 'add-affirmation': {
                    const input = document.getElementById('new-affirmation-input');
                    const text = input.value.trim();
                    if (text) {
                        performAction({ type: 'ADD_AFFIRMATION', payload: { id: `aff_${Date.now()}`, text } });
                        input.value = '';
                        renderLibraryContent('my-affirmations');
                    }
                    break;
                }
                case 'delete-affirmation': {
                    performAction({ type: 'DELETE_AFFIRMATION', payload: { id: target.dataset.affirmationId } });
                    renderLibraryContent('my-affirmations');
                    break;
                }

                // Audio
                case 'record-voice': startRecording(mantraId); break;
                case 'stop-recording': stopRecording(); break;
                case 'play-voice': playRecording(mantraId); break;
                case 'pause-voice': pauseRecording(); break;
                case 'stop-voice': stopPlayback(); break;
                case 'delete-voice': deleteRecording(mantraId); break;

                // Dashboard
                case 'set-mantra-index':
                    stopSlideshow();
                    state.currentMantraIndex = parseInt(target.dataset.index, 10);
                    renderDashboard();
                    break;

                // Progress
                case 'prev-month':
                    calendarViewDate.setMonth(calendarViewDate.getMonth() - 1);
                    renderProgress();
                    break;
                case 'next-month':
                    calendarViewDate.setMonth(calendarViewDate.getMonth() + 1);
                    renderProgress();
                    break;
                
                // Settings & Data
                case 'export-data': exportUserData(); break;
                case 'import-data': handleImportData(); break;
                case 'reset-app': handleResetApp(); break;
                case 'clear-audio':
                     renderConfirmationModal('Clear All Recordings?', 'This will delete all your voice recordings permanently.', () => {
                        state.audioRecordings = {};
                        saveState();
                        renderToast('All recordings deleted.');
                        renderSettings();
                     }, { confirmText: 'Clear All', confirmVariant: 'destructive' });
                     break;
                case 'rerun-ai-check':
                     checkAiStatus().then(() => {
                        renderSettings();
                        renderToast('AI Diagnostics re-run.');
                     });
                     break;
                
                // AI Features
                case 'open-ai-generate-modal': renderAiGenerateModal(); break;
                case 'start-ai-topic-recording': startAiTopicRecording(); break;
                case 'stop-ai-topic-recording': stopAiTopicRecording(); break;
                case 'generate-ai-mantras': handleGenerateAiMantras(); break;
                case 'add-generated-mantra': {
                    const text = decodeURIComponent(target.dataset.text);
                    const newMantra = {
                        id: `ai_${Date.now()}`,
                        text: { original: text, translated: null },
                        category: 'AI Generated',
                        priority: 'Medium',
                        createdAt: Date.now(),
                        isCustom: true,
                    };
                    performAction({ type: 'ADD_MANTRA', payload: newMantra });
                    renderToast('Mantra added!');
                    target.innerHTML = ICONS.Check({size: 16});
                    target.disabled = true;
                    break;
                }
                case 'open-ai-affirmation-modal': renderAiAffirmationModal(); break;
                case 'generate-ai-affirmations': handleGenerateAiAffirmations(); break;
                case 'add-generated-affirmation': {
                    const text = decodeURIComponent(target.dataset.text);
                    performAction({ type: 'ADD_AFFIRMATION', payload: { id: `aff_${Date.now()}`, text } });
                    renderToast('Affirmation added!');
                    target.innerHTML = ICONS.Check({size: 16});
                    target.disabled = true;
                    break;
                }
                case 'translate-mantra': {
                    const mantraToTranslate = state.userMantras.find(m => m.id === mantraId) || CURATED_MANTRAS.find(m => m.id === mantraId);
                    if (mantraToTranslate) renderTranslateModal(mantraToTranslate);
                    break;
                }
                case 'perform-translation': handlePerformTranslation(mantraId); break;
                case 'save-translation': handleSaveTranslation(mantraId); break;
                
                // Undo/Redo
                case 'undo': undo(); break;
                case 'redo': redo(); break;
            }
        });

        document.body.addEventListener('change', e => {
            const settingTarget = e.target.closest('[data-setting]');
            if (settingTarget) {
                const path = settingTarget.dataset.setting;
                let value;
                if (settingTarget.type === 'checkbox') {
                    value = settingTarget.checked;
                } else if (settingTarget.tagName === 'BUTTON') {
                    value = settingTarget.dataset.value;
                } else {
                    value = settingTarget.type === 'range' ? parseInt(settingTarget.value, 10) : settingTarget.value;
                }
                setNestedValue(state.settings, path, value);
                saveState();
                applySettings();
                handleHashChange(); // Re-render to apply changes immediately
                return;
            }

            const sortTarget = e.target.closest('#my-mantras-sort');
            if (sortTarget) {
                myMantrasSortOrder = sortTarget.value;
                renderLibraryContent('my-mantras');
                return;
            }
        });
        
        document.body.addEventListener('input', e => {
             const searchTarget = e.target.closest('#mantra-search-input');
             if(searchTarget) {
                 const activeCategory = document.querySelector('[data-action="library-filter"][class*="bg-white"]')?.dataset.category || CATEGORIES[0];
                 renderLibraryContent('curated', { category: activeCategory, searchTerm: searchTarget.value });
             }
        });

        audioPlayer.addEventListener('timeupdate', () => {
            if (!currentlyPlayingMantraId) return;
            const bar = document.querySelector(`.audio-progress-bar-inner[data-mantra-id="${currentlyPlayingMantraId}"]`);
            if (bar) {
                const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                bar.style.width = `${progress}%`;
            }
        });
        audioPlayer.addEventListener('ended', stopPlayback);
    };
    
    const handleMantraFormSubmit = (mantraId) => {
        const text = document.getElementById('mantra-form-text').value.trim();
        if (!text) {
            renderToast('Please enter mantra text.');
            return;
        }

        const mantraData = {
            text: { original: text, translated: null },
            category: document.getElementById('mantra-form-category').value,
            priority: document.getElementById('mantra-form-priority').value,
        };

        if (mantraId) { // Editing existing mantra
            performAction({ type: 'UPDATE_MANTRA', payload: { id: mantraId, ...mantraData } });
        } else { // Creating new mantra
            const newMantra = {
                id: `custom_${Date.now()}`,
                ...mantraData,
                createdAt: Date.now(),
                isCustom: true,
            };
            performAction({ type: 'ADD_MANTRA', payload: newMantra });
            unlockAchievement('custom_mantra');
        }
        document.getElementById('create-edit-mantra-modal')?.remove();
        renderLibraryContent('my-mantras');
    };

    const renderCreateEditMantraModal = (mantra = null) => {
        const modalId = 'create-edit-mantra-modal';
        document.getElementById(modalId)?.remove();
        const colors = getTextColorClasses();
        const isEditing = mantra !== null;

        const modalHTML = `
            <div id="${modalId}" class="fixed inset-0 bg-black/70 z-[100] flex items-center justify-center p-4 animate-fade-in">
                <div class="glass-card w-full max-w-md rounded-2xl p-6 animate-slide-in-up">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-serif">${isEditing ? 'Edit Mantra' : 'Create New Mantra'}</h2>
                        <button data-action="close-modal-by-id" data-modal-id="${modalId}" class="p-2 ${colors.bgMuted} ${colors.bgHover} rounded-full">&times;</button>
                    </div>
                    <form class="space-y-4">
                        <textarea id="mantra-form-text" class="w-full h-28 p-3 ${colors.bgMuted} rounded-lg ${colors.placeholder} focus:outline-none focus:ring-2 ${colors.ring}" placeholder="e.g., I am a creative powerhouse.">${mantra?.text?.original || ''}</textarea>
                        <select id="mantra-form-category" class="w-full p-3 ${colors.bgMuted} rounded-lg focus:outline-none focus:ring-2 ${colors.ring}">
                            ${CATEGORIES.map(cat => `<option value="${cat}" ${mantra?.category === cat ? 'selected' : ''}>${cat}</option>`).join('')}
                        </select>
                        <select id="mantra-form-priority" class="w-full p-3 ${colors.bgMuted} rounded-lg focus:outline-none focus:ring-2 ${colors.ring}">
                            ${PRIORITY_LEVELS.map(p => `<option value="${p}" ${mantra?.priority === p ? 'selected' : ''}>${p} Priority</option>`).join('')}
                        </select>
                        <div class="text-right">
                           ${renderButton(isEditing ? 'Save Changes' : 'Create Mantra', { attributes: `data-action="submit-mantra-form" ${isEditing ? `data-mantra-id="${mantra.id}"` : ''}`})}
                        </div>
                    </form>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHTML);
    };
    
    const handleImportData = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json';
        input.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedState = JSON.parse(event.target.result);
                    renderConfirmationModal('Overwrite Data?', 'Importing this file will replace all your current mantras, progress, and settings. This cannot be undone.', () => {
                        // Basic validation
                        if (importedState.userMantras && importedState.settings) {
                            Object.keys(state).forEach(key => {
                                if (importedState[key] !== undefined) {
                                    state[key] = importedState[key];
                                }
                            });
                            saveState();
                            loadState(); // Re-load to apply migrations etc.
                            renderToast('Data imported successfully!');
                            setTimeout(() => window.location.reload(), 1000);
                        } else {
                           renderModal('Import Failed', 'The selected file does not appear to be a valid MantraOS backup.');
                        }
                    });
                } catch (error) {
                    renderModal('Import Error', 'There was an error reading the backup file. It may be corrupted.');
                }
            };
            reader.readAsText(file);
        };
        input.click();
    };

    const handleResetApp = () => {
        renderConfirmationModal('Reset Application?', 'This will permanently delete all your mantras, progress, and settings. This action cannot be undone.', () => {
            Object.keys(storageKeys).forEach(key => localStorage.removeItem(storageKeys[key]));
            renderToast('Application has been reset.');
            setTimeout(() => window.location.reload(), 1000);
        }, { confirmText: 'Reset Forever', confirmVariant: 'destructive' });
    };

    const initApp = () => {
        loadState();
        applySettings();
        checkAiStatus();
        handleHashChange();
        setupEventListeners();

        window.addEventListener('hashchange', handleHashChange);
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredInstallPrompt = e;
        });
        
        // Keyboard shortcuts for undo/redo
        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });
    };

    initApp();

  </script>
</body>
</html>